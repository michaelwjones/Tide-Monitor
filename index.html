<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://tide-monitor-boron-default-rtdb.firebaseio.com data:;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tide Monitor - Recent Readings</title>
    <style>
        table, th, td {
            border: 1px solid black;
        }
        table {
            border-collapse: collapse;
        }
        .hidden {
            display: none;
        }
        .debug-link {
            background: #28a745;
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            display: inline-block;
            margin-top: 10px;
        }
        .debug-link:hover {
            background: #218838;
            color: white;
            text-decoration: none;
        }
        .wind-direction-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        .wind-arrow {
            width: 2px;
            height: 25px;
            background: black;
            position: relative;
            transform-origin: center bottom;
        }
        .wind-arrow::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 8px solid black;
        }
        .chart-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    
    <h1>Tide Monitor</h1>
    
    <div id="loading">Loading...</div>
    
    <div id="content" class="hidden">
        <div class="chart-container">
            <canvas id="waterLevelChart" width="800" height="500"></canvas>
            <div id="windDirectionIndicator" class="wind-direction-indicator" style="display: none;">
                <div class="wind-arrow" id="windArrow"></div>
            </div>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 10px;">
            <div id="chartLegend" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-size: 14px; flex: 1;"></div>
            <a href="debug/" class="debug-link">Debug Dashboard →</a>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            fetchTideData();
            
            // Auto-refresh every 2 minutes (120,000 milliseconds)
            setInterval(fetchTideData, 120000);
        });

        let chartInstance = null;
        let currentReadings = [];

        // Round wind direction to nearest 22.5 degrees (16 compass directions)
        function roundWindDirection(degrees) {
            if (degrees === null || degrees === undefined || isNaN(degrees)) return null;
            return Math.round(degrees / 22.5) * 22.5;
        }

        // Update wind direction indicator
        function updateWindDirectionIndicator(readings) {
            const indicator = document.getElementById('windDirectionIndicator');
            const arrow = document.getElementById('windArrow');
            
            if (!readings || readings.length === 0 || !chartInstance) {
                indicator.style.display = 'none';
                return;
            }
            
            // Get the most recent wind direction and speed readings
            const latestReading = readings[readings.length - 1];
            const windDirection = latestReading.windDirection;
            const windSpeed = latestReading.windSpeedRaw;
            
            if (windDirection === '--' || windDirection === null || windDirection === undefined ||
                windSpeed === null || windSpeed === undefined) {
                indicator.style.display = 'none';
                return;
            }
            
            // Find the wind speed dataset
            const windSpeedDataset = chartInstance.data.datasets.find(ds => ds.label === 'Wind Speed (knots)');
            if (!windSpeedDataset || windSpeedDataset.data.length === 0) {
                indicator.style.display = 'none';
                return;
            }
            
            // Get the latest wind speed data point
            const latestWindData = windSpeedDataset.data[windSpeedDataset.data.length - 1];
            if (!latestWindData) {
                indicator.style.display = 'none';
                return;
            }
            
            // Get chart dimensions and scales
            const chartArea = chartInstance.chartArea;
            const xScale = chartInstance.scales.x;
            const yScale = chartInstance.scales.windSpeed;
            
            // Calculate pixel position of the latest wind speed point
            const pixelX = xScale.getPixelForValue(latestWindData.x);
            const pixelY = yScale.getPixelForValue(latestWindData.y);
            
            // Position indicator so the arrow BASE starts at the wind plot endpoint
            // Arrow is 25px tall, so we need to offset the container so the bottom of the arrow is at the endpoint
            indicator.style.left = `${pixelX - 1}px`; // Center the 2px wide arrow
            indicator.style.top = `${pixelY - 25}px`; // Position so bottom of arrow is at the endpoint
            
            // Round to nearest 22.5 degrees
            const roundedDirection = roundWindDirection(parseFloat(windDirection));
            
            // Rotate arrow to point in wind direction (0° = North = up)
            // Wind direction indicates where wind comes FROM, so add 180° to show where it's blowing TO
            arrow.style.transform = `rotate(${roundedDirection + 180}deg)`;
            
            // Show the indicator
            indicator.style.display = 'block';
            
            // Update tooltip with direction info
            indicator.title = `Wind Direction: ${roundedDirection}°`;
        }

        // Prepare data for cubic spline interpolation with light smoothing (Wind/Wave category)
        function prepareWindWaveSplineData(data) {
            const n = data.length;
            if (n < 4) return null;
            
            // Sort data by x value and remove duplicates
            const sortedData = [...data].sort((a, b) => a.x.getTime() - b.x.getTime());
            const uniqueData = [];
            
            for (let i = 0; i < sortedData.length; i++) {
                if (i === 0 || sortedData[i].x.getTime() !== sortedData[i-1].x.getTime()) {
                    uniqueData.push(sortedData[i]);
                }
            }
            
            if (uniqueData.length < 4) return null;
            
            // Apply progressive smoothing with up to 30-point moving average
            const lightlySmoothed = [];
            for (let i = 0; i < uniqueData.length; i++) {
                // Determine smoothing window size based on distance from edges
                const distFromStart = i;
                const distFromEnd = uniqueData.length - 1 - i;
                const maxRadius = Math.min(distFromStart, distFromEnd);
                
                // Progressive smoothing: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 30 point averages
                const windowSizes = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 30];
                const radius = Math.min(maxRadius, Math.floor((windowSizes.length - 1)));
                const windowSize = windowSizes[radius];
                const halfWindow = Math.floor(windowSize / 2);
                
                // Calculate moving average
                let sum = 0;
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    sum += uniqueData[i + j].y;
                }
                const smoothedY = sum / windowSize;
                
                lightlySmoothed.push({
                    x: uniqueData[i].x,
                    y: smoothedY
                });
            }
            
            return {
                data: lightlySmoothed,
                type: 'cubic_spline'
            };
        }

        // Natural cubic spline computation using Thomas algorithm (O(n) complexity) for Wind/Wave category
        function computeWindWaveNaturalCubicSpline(data) {
            const n = data.length;
            if (n < 4) return null;
            
            const x = data.map(d => d.x.getTime());
            const y = data.map(d => d.y);
            
            // Calculate intervals
            const h = new Array(n - 1);
            for (let i = 0; i < n - 1; i++) {
                h[i] = x[i + 1] - x[i];
                if (h[i] === 0) return null; // Avoid division by zero
            }
            
            // Set up the tridiagonal system for natural spline
            const alpha = new Array(n - 1);
            for (let i = 1; i < n - 1; i++) {
                alpha[i] = (3 / h[i]) * (y[i + 1] - y[i]) - (3 / h[i - 1]) * (y[i] - y[i - 1]);
            }
            
            // Solve tridiagonal system using Thomas algorithm
            const l = new Array(n);
            const mu = new Array(n);
            const z = new Array(n);
            
            l[0] = 1;
            mu[0] = 0;
            z[0] = 0;
            
            for (let i = 1; i < n - 1; i++) {
                l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
            }
            
            l[n - 1] = 1;
            z[n - 1] = 0;
            
            // Back substitution
            const c = new Array(n);
            c[n - 1] = 0;
            
            for (let j = n - 2; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
            }
            
            // Calculate spline coefficients
            const a = new Array(n);
            const b = new Array(n);
            const d = new Array(n);
            
            for (let i = 0; i < n - 1; i++) {
                a[i] = y[i];
                b[i] = (y[i + 1] - y[i]) / h[i] - h[i] * (c[i + 1] + 2 * c[i]) / 3;
                d[i] = (c[i + 1] - c[i]) / (3 * h[i]);
            }
            
            return {
                x: x,
                a: a,
                b: b,
                c: c,
                d: d,
                n: n
            };
        }

        // Evaluate cubic spline at given x values for Wind/Wave category
        function evaluateWindWaveCubicSpline(spline, xValues) {
            const points = [];
            
            for (const targetX of xValues) {
                const x = targetX.getTime();
                
                // Find the interval containing x
                let i = 0;
                while (i < spline.n - 1 && x > spline.x[i + 1]) {
                    i++;
                }
                
                // Clamp to valid range
                i = Math.max(0, Math.min(i, spline.n - 2));
                
                const dx = x - spline.x[i];
                const y = spline.a[i] + spline.b[i] * dx + spline.c[i] * dx * dx + spline.d[i] * dx * dx * dx;
                
                points.push({
                    x: targetX,
                    y: y
                });
            }
            
            return points;
        }

        // Generate tight-fitting trend line data points using cubic splines for Wind/Wave category
        function generateWindWaveTrendLine(data, splineData) {
            if (!splineData || !splineData.data || splineData.data.length < 4) return [];
            
            // Compute natural cubic spline directly from the data
            const spline = computeWindWaveNaturalCubicSpline(splineData.data);
            if (!spline) return [];
            
            // Generate evaluation points for smooth curve
            const firstTime = splineData.data[0].x.getTime();
            const lastTime = splineData.data[splineData.data.length - 1].x.getTime();
            const timeRange = lastTime - firstTime;
            
            const evalPoints = [];
            const numPoints = Math.min(200, splineData.data.length * 3); // More points for tighter curves
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const currentTime = firstTime + t * timeRange;
                evalPoints.push(new Date(currentTime));
            }
            
            // Evaluate spline at these points
            return evaluateWindWaveCubicSpline(spline, evalPoints);
        }

        // Fetch Transformer 24-hour forecasts from Firebase
        async function fetchTransformerPredictions() {
            try {
                // Try v2 first, then fallback to v1
                const sources = [
                    { url: 'https://tide-monitor-boron-default-rtdb.firebaseio.com/tidal-analysis/transformer-v2-forecast.json', version: 'v2' },
                    { url: 'https://tide-monitor-boron-default-rtdb.firebaseio.com/tidal-analysis/transformer-v1-forecast.json', version: 'v1' }
                ];
                
                for (const source of sources) {
                    try {
                        const response = await fetch(source.url);
                        const data = await response.json();
                        
                        if (!data || !data.forecast) {
                            console.log(`No Transformer ${source.version} forecasts found`);
                            continue;
                        }
                        
                        // Check if forecast was updated in the last 10 minutes
                        const generatedAt = new Date(data.generated_at);
                        const now = new Date();
                        const timeDiff = (now - generatedAt) / (1000 * 60); // minutes
                        
                        if (timeDiff > 10) {
                            console.log(`Transformer ${source.version} forecast is ${timeDiff.toFixed(1)} minutes old, not showing`);
                            continue;
                        }
                        
                        console.log(`Fetched Transformer ${source.version} forecast: ${data.forecast.length} predictions`);
                        
                        // Each prediction has: timestamp (ISO string), prediction (mm), step
                        const predictions = data.forecast.map(pred => ({
                            timestamp: new Date(pred.timestamp),
                            prediction: pred.prediction, // Keep in mm
                            step: pred.step
                        }));
                        
                        return {
                            predictions: predictions,
                            generatedAt: generatedAt,
                            modelVersion: data.model_version,
                            inputDataCount: data.input_data_count,
                            version: source.version
                        };
                        
                    } catch (error) {
                        console.log(`Error fetching Transformer ${source.version} predictions:`, error);
                        continue;
                    }
                }
                
                console.log('No recent Transformer forecasts found');
                return null;
                
            } catch (error) {
                console.error('Error fetching Transformer predictions:', error);
                return null;
            }
        }

        async function fetchTideData() {
            // Make two asynchronous calls
            const [historyResponse, forecastData] = await Promise.allSettled([
                fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/readings/.json?orderBy="$key"&limitToLast=1440'),
                fetchTransformerPredictions()
            ]);

            let readings = [];
            if (historyResponse.status === 'fulfilled') {
                const data = await historyResponse.value.json();
                readings = Object.entries(data).map(([key, value]) => ({
                    id: key,
                    timestamp: new Date(value.t).toLocaleString('en-US', { 
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    }),
                    rawTimestamp: new Date(value.t),
                    wavesPercentile: (value.hp !== undefined && value.hp !== null) ? (value.hp / 304.8).toFixed(2) : '--',
                    waterLevel: (value.w / 304.8).toFixed(2),
                    windSpeed: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944).toFixed(1) : '--', // Convert m/s to knots
                    windSpeedRaw: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944) : null,
                    windDirection: (value.wd !== undefined && value.wd !== null && value.wd !== "-999") ? parseFloat(value.wd).toFixed(0) : '--'
                }));
            }

            // Store readings for wind direction indicator
            currentReadings = readings;
            
            // Get forecast data if available
            let transformerData = null;
            if (forecastData.status === 'fulfilled') {
                transformerData = forecastData.value;
            }
            
            // Create chart with history data and optionally forecast data
            createChart(readings, transformerData);
            
            // Hide loading and show content
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('content').classList.remove('hidden');
        }

        function createChart(readings, transformerData = null) {
            // Destroy existing chart if it exists
            if (chartInstance) {
                chartInstance.destroy();
            }
            
            const ctx = document.getElementById('waterLevelChart').getContext('2d');
            
            // Filter out any invalid timestamps
            const validReadings = readings.filter(r => r.rawTimestamp.getTime() > 0);
            
            // Generate smoothed waves (percentile) trend line
            const wavesRawData = validReadings.filter(r => r.wavesPercentile !== '--').map(r => ({
                x: r.rawTimestamp, 
                y: parseFloat(r.wavesPercentile)
            }));
            
            let wavesTrendData = [];
            if (wavesRawData.length >= 4) {
                const splineData = prepareWindWaveSplineData(wavesRawData);
                if (splineData) {
                    wavesTrendData = generateWindWaveTrendLine(wavesRawData, splineData);
                }
            }
            
            // Generate smoothed wind speed trend line (already converted to knots)
            const windRawData = validReadings.filter(r => r.windSpeedRaw !== null).map(r => ({
                x: r.rawTimestamp,
                y: r.windSpeedRaw
            }));
            
            let windTrendData = [];
            if (windRawData.length >= 4) {
                const splineData = prepareWindWaveSplineData(windRawData);
                if (splineData) {
                    windTrendData = generateWindWaveTrendLine(windRawData, splineData);
                }
            }
            
            // Determine time range based on forecast availability
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            
            // Prepare forecast dataset if available
            let forecastDataset = null;
            let hasForecast = false;
            if (transformerData && transformerData.predictions) {
                hasForecast = true;
                // Convert predictions to chart data (water level in feet, points only)
                const predictionData = transformerData.predictions.map(pred => ({
                    x: pred.timestamp,
                    y: pred.prediction / 304.8 // Convert mm to feet
                }));
                
                forecastDataset = {
                    label: 'Water Level Forecast (ft)',
                    data: predictionData,
                    borderColor: 'orange',
                    backgroundColor: 'orange',
                    fill: false,
                    showLine: false, // Don't connect points with lines
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    yAxisID: 'y',
                    order: 5
                };
            }

            // Set time range and horizontal line based on forecast availability
            const maxTime = hasForecast ? new Date(now.getTime() + (24 * 60 * 60 * 1000)) : now;
            const horizontalLineData = [
                {x: twentyFourHoursAgo, y: 3},
                {x: maxTime, y: 3}
            ];
            
            // Build datasets array, including forecast if available
            const datasets = [{
                label: 'Water Level (ft)',
                data: validReadings.map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevel)})),
                borderColor: 'blue',
                backgroundColor: 'rgba(0, 0, 255, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                pointHoverRadius: 0,
                tension: 0.6,
                order: 1
            }, {
                label: 'Waves (ft)',
                data: wavesTrendData.length > 0 ? wavesTrendData : validReadings.filter(r => r.wavesPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesPercentile)})),
                borderColor: 'red',
                backgroundColor: 'rgba(255, 0, 0, 0.1)',
                borderWidth: 1,
                pointRadius: 0,
                pointHoverRadius: 0,
                tension: 0.5,
                order: 2,
                yAxisID: 'waveHeight'
            }, {
                label: 'Wind Speed (knots)',
                data: windTrendData.length > 0 ? windTrendData : windRawData,
                borderColor: 'purple',
                backgroundColor: 'rgba(128, 0, 128, 0.1)',
                borderWidth: 1,
                pointRadius: 0,
                pointHoverRadius: 0,
                tension: 0.5,
                order: 3,
                yAxisID: 'windSpeed'
            }, {
                label: 'Reference Line',
                data: horizontalLineData,
                borderColor: 'green',
                borderWidth: 2,
                pointRadius: 0,
                pointHoverRadius: 0,
                fill: false,
                tension: 0,
                order: 0
            }];

            // Add forecast dataset if available
            if (forecastDataset) {
                datasets.push(forecastDataset);
            }

            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    animation: false,
                    responsive: true,
                    scales: {
                        y: {
                            min: 0,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Water Level (feet)'
                            },
                            position: 'left'
                        },
                        waveHeight: {
                            type: 'linear',
                            min: 0,
                            max: 2,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Wave Height (feet)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        windSpeed: {
                            type: 'linear',
                            min: 0,
                            max: 40,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Wind Speed (knots)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            offset: true
                        },
                        x: {
                            type: 'time',
                            min: twentyFourHoursAgo,
                            max: maxTime,
                            time: {
                                displayFormats: {
                                    hour: 'h:mm a'
                                }
                            },
                            title: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false
                        }
                    }
                }
            });
            
            // Generate custom legend
            const legendContainer = document.getElementById('chartLegend');
            if (legendContainer) {
                const legendItems = [
                    { label: 'Water Level (ft)', color: 'blue' },
                    { label: 'Waves (ft)', color: 'red' },
                    { label: 'Wind Speed (knots)', color: 'purple' },
                    { label: 'Reference Line', color: 'green' }
                ];

                // Add forecast to legend if available
                if (transformerData && transformerData.predictions) {
                    legendItems.push({ 
                        label: 'Water Level Forecast (ft)', 
                        color: 'orange' 
                    });
                }
                
                legendContainer.innerHTML = legendItems.map(item => `
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 16px; height: 3px; background-color: ${item.color}; display: inline-block;"></span>
                        <span>${item.label}</span>
                    </span>
                `).join('');
            }
            
            // Update wind direction indicator after chart is fully rendered
            setTimeout(() => updateWindDirectionIndicator(currentReadings), 100);
        }
    </script>
</body>
</html>