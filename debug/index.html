<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://tide-monitor-boron-default-rtdb.firebaseio.com data:;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tide Monitor - Debug Dashboard</title>
    <style>
        .hidden {
            display: none;
        }
        .main-link {
            background: #28a745;
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            display: inline-block;
        }
        .main-link:hover {
            background: #218838;
            color: white;
            text-decoration: none;
        }
        .toggle-prediction {
            background: #17a2b8;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            cursor: pointer;
            margin-left: 10px;
        }
        .toggle-prediction:hover {
            background: #138496;
        }
        .toggle-prediction.active {
            background: #fd7e14;
        }
        .toggle-prediction.active:hover {
            background: #e8650f;
        }
        .toggle-trendlines {
            background: #007bff;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            cursor: pointer;
            margin-left: 10px;
        }
        .toggle-trendlines:hover {
            background: #0056b3;
        }
        #debugChart {
            max-height: 600px;
            width: 100%;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body>
    
    <h1>Tide Monitor - Debug Dashboard</h1>
    
    <div id="loading">Loading...</div>
    
    <div id="content" class="hidden">
        <canvas id="debugChart" width="800" height="500"></canvas>
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 10px;">
            <div id="chartLegend" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-size: 14px; flex: 1;"></div>
            <div style="display: flex; align-items: center;">
                <a href="../index.html" class="main-link">‚Üê Main Dashboard</a>
                <button id="togglePrediction" class="toggle-prediction hidden">Show Forecast</button>
                <button id="show24Hours" class="toggle-trendlines" style="background: #007bff; margin-left: 10px;">24 Hours</button>
                <button id="show72Hours" class="toggle-trendlines" style="background: #6c757d; margin-left: 5px;">72 Hours</button>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            fetchDebugData();
            
            // Auto-refresh every 2 minutes (120,000 milliseconds)
            setInterval(fetchDebugData, 120000);
        });

        let debugChartInstance = null;
        let predictionVisible = false;
        let currentReadings = [];

        async function fetchDebugData() {
            try {
                console.log('Fetching debug data...');
                
                // Fetch last 4320 readings (72 hours)
                const response = await fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/readings.json?orderBy="$key"&limitToLast=4320');
                const data = await response.json();
                
                if (!data) {
                    document.getElementById('loading').textContent = 'No data available';
                    return;
                }

                // Convert Firebase data to array with all measurements
                const allReadings = Object.entries(data).map(([key, value]) => ({
                    timestamp: new Date(value.t),
                    rawTimestamp: new Date(value.t),
                    waterLevel: (value.w / 304.8).toFixed(2), // Convert mm to feet
                    waterLevelRaw: value.w / 304.8,
                    waveHeightPercentile: value.hp ? (value.hp / 304.8).toFixed(2) : '--',
                    waveHeightPercentileRaw: value.hp ? value.hp / 304.8 : null,
                    waveHeightEnvelope: value.he ? (value.he / 304.8).toFixed(2) : '--',
                    waveHeightEnvelopeRaw: value.he ? value.he / 304.8 : null,
                    waterLevelPercentile: value.wp ? (value.wp / 304.8).toFixed(2) : '--',
                    waterLevelPercentileRaw: value.wp ? value.wp / 304.8 : null,
                    waterLevelEnvelope: value.we ? (value.we / 304.8).toFixed(2) : '--',
                    waterLevelEnvelopeRaw: value.we ? value.we / 304.8 : null,
                    validSamples: value.vs || '--',
                    validSamplesRaw: value.vs || 0,
                    windSpeed: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944).toFixed(1) : '--',
                    windSpeedRaw: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944) : null,
                    windDirection: (value.wd !== undefined && value.wd !== null && value.wd !== "-999") ? parseFloat(value.wd).toFixed(0) : '--',
                    gustSpeed: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944).toFixed(1) : '--',
                    gustSpeedRaw: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944) : null,
                    dukeWaterLevel: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm).toFixed(2) : '--',
                    dukeWaterLevelRaw: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm) : null
                }));
                
                // Store readings for chart display
                currentReadings = allReadings;
                
                // Check for transformer forecast availability
                const transformerData = await fetchTransformerPredictions();
                if (transformerData) {
                    document.getElementById('togglePrediction').classList.remove('hidden');
                } else {
                    document.getElementById('togglePrediction').classList.add('hidden');
                }
                
                // Create debug chart
                createDebugChart(allReadings);
                
                // Hide loading and show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');
            } catch (error) {
                console.error('Error fetching debug data:', error);
                document.getElementById('loading').textContent = 'Error loading data. Check console for details.';
            }
        }

        // Fetch Transformer 24-hour forecasts from Firebase
        async function fetchTransformerPredictions() {
            try {
                const response = await fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/tidal-analysis/transformer-v1-forecast.json');
                const data = await response.json();
                
                if (!data || !data.forecast) {
                    console.log('No Transformer forecasts found');
                    return null;
                }
                
                // Check if forecast was updated in the last 10 minutes
                const generatedAt = new Date(data.generated_at);
                const now = new Date();
                const timeDiff = (now - generatedAt) / (1000 * 60); // minutes
                
                if (timeDiff > 10) {
                    console.log(`Transformer forecast is ${timeDiff.toFixed(1)} minutes old, not showing`);
                    return null;
                }
                
                console.log(`Fetched Transformer forecast: ${data.forecast.length} predictions`);
                
                // Each prediction has: timestamp (ISO string), prediction (mm), step
                const predictions = data.forecast.map(pred => ({
                    timestamp: new Date(pred.timestamp),
                    prediction: pred.prediction, // Keep in mm
                    step: pred.step
                }));
                
                return {
                    predictions: predictions,
                    generatedAt: generatedAt,
                    modelVersion: data.model_version,
                    inputDataCount: data.input_data_count
                };
                
            } catch (error) {
                console.error('Error fetching Transformer predictions:', error);
                return null;
            }
        }

        function createDebugChart(readings) {
            // Destroy existing chart if it exists
            if (debugChartInstance) {
                debugChartInstance.destroy();
            }
            
            const ctx = document.getElementById('debugChart').getContext('2d');

            // Set initial time range to last 24 hours
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));

            debugChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Water Level (ft)',
                        data: readings.map(r => ({x: r.rawTimestamp, y: r.waterLevelRaw})),
                        borderColor: 'blue',
                        backgroundColor: 'rgba(0, 0, 255, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.6,
                        order: 1
                    }, {
                        label: 'Waves (ft)',
                        data: readings.map(r => ({x: r.rawTimestamp, y: r.waveHeightPercentileRaw})).filter(p => p.y !== null),
                        borderColor: 'red',
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.5,
                        order: 2,
                        yAxisID: 'waveHeight'
                    }, {
                        label: 'Wind Speed (knots)',
                        data: readings.map(r => ({x: r.rawTimestamp, y: r.windSpeedRaw})).filter(p => p.y !== null),
                        borderColor: 'purple',
                        backgroundColor: 'rgba(128, 0, 128, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.5,
                        order: 3,
                        yAxisID: 'windSpeed'
                    }, {
                        label: 'Reference Line',
                        data: [{x: twentyFourHoursAgo, y: 2.5}, {x: now, y: 2.5}],
                        borderColor: 'green',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        fill: false,
                        tension: 0,
                        order: 0
                    }]
                },
                options: {
                    animation: false,
                    responsive: true,
                    scales: {
                        y: {
                            min: 0,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Water Level (feet)'
                            },
                            position: 'left'
                        },
                        waveHeight: {
                            type: 'linear',
                            min: 0,
                            max: 2,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Wave Height (feet)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        windSpeed: {
                            type: 'linear',
                            min: 0,
                            max: 40,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Wind Speed (knots)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            offset: true
                        },
                        x: {
                            type: 'time',
                            min: twentyFourHoursAgo,
                            max: now,
                            time: {
                                displayFormats: {
                                    hour: 'h:mm a'
                                }
                            },
                            title: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false
                        }
                    }
                }
            });

            // Create custom legend
            createCustomLegend();
        }

        function createCustomLegend() {
            const legendContainer = document.getElementById('chartLegend');
            if (!debugChartInstance) return;

            const legendItems = [
                { label: 'Water Level (ft)', color: 'blue' },
                { label: 'Waves (ft)', color: 'red' },
                { label: 'Wind Speed (knots)', color: 'purple' },
                { label: 'Reference Line', color: 'green' }
            ];

            legendContainer.innerHTML = legendItems.map(item => `
                <span style="display: flex; align-items: center; gap: 5px;">
                    <span style="width: 16px; height: 3px; background-color: ${item.color}; display: inline-block;"></span>
                    <span>${item.label}</span>
                </span>
            `).join('');
        }

        // Add Transformer predictions to the chart
        async function addTransformerPredictions() {
            const forecastData = await fetchTransformerPredictions();
            
            if (!forecastData || !debugChartInstance) {
                return;
            }
            
            // Convert predictions to chart data (water level in feet, points only)
            const predictionData = forecastData.predictions.map(pred => ({
                x: pred.timestamp,
                y: pred.prediction / 304.8 // Convert mm to feet
            }));
            
            // Add prediction dataset to chart (points only, no connecting lines)
            const predictionDataset = {
                label: 'Transformer 24h Forecast',
                data: predictionData,
                borderColor: 'purple',
                backgroundColor: 'purple',
                fill: false,
                showLine: false, // Don't connect points with lines
                pointRadius: 3,
                pointHoverRadius: 5,
                yAxisID: 'y'
            };
            
            // Add dataset to chart
            debugChartInstance.data.datasets.push(predictionDataset);
            debugChartInstance.update('none');
            
            console.log(`Added Transformer predictions: ${predictionData.length} points`);
        }

        // Remove Transformer predictions from the chart
        function removeTransformerPredictions() {
            if (!debugChartInstance) return;
            
            // Find and remove Transformer prediction dataset
            debugChartInstance.data.datasets = debugChartInstance.data.datasets.filter(
                dataset => dataset.label !== 'Transformer 24h Forecast'
            );
            debugChartInstance.update('none');
            
            console.log('Removed Transformer predictions from chart');
        }

        // Toggle 24-hour prediction visibility
        async function togglePrediction() {
            const button = document.getElementById('togglePrediction');
            
            // Check current button text to determine action
            if (button.textContent === 'Show Forecast') {
                // User wants to SHOW forecast - extend chart and add data
                predictionVisible = true;
                button.textContent = 'Hide Forecast';
                button.classList.add('active');
                
                // Add Transformer predictions to the chart
                await addTransformerPredictions();
                
                // Extend chart x-axis to show 24 hours into future for prediction
                if (debugChartInstance) {
                    const now = new Date();
                    const extendedMax = new Date(now.getTime() + (24 * 60 * 60 * 1000)); // Add 24 hours from now
                    debugChartInstance.options.scales.x.max = extendedMax;
                    
                    // Also update zoom limits to allow viewing the prediction
                    debugChartInstance.options.plugins.zoom.limits.x.max = extendedMax;
                    debugChartInstance.update('none'); // Update without animation for smooth transition
                }
            } else {
                // User wants to HIDE forecast - contract chart and remove data
                predictionVisible = false;
                button.textContent = 'Show Forecast';
                button.classList.remove('active');
                
                // Remove Transformer predictions from chart
                removeTransformerPredictions();
                
                // Reset chart x-axis to current time (remove future prediction view)
                if (debugChartInstance) {
                    const now = new Date();
                    debugChartInstance.options.scales.x.max = now;
                    
                    // Reset zoom limits to current time
                    debugChartInstance.options.plugins.zoom.limits.x.max = now;
                    debugChartInstance.update('none'); // Update without animation for smooth transition
                }
            }
        }

        // Initialize event listeners
        window.addEventListener('load', function() {
            document.getElementById('togglePrediction').addEventListener('click', togglePrediction);
            
            document.getElementById('show24Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                    debugChartInstance.options.scales.x.min = twentyFourHoursAgo;
                    
                    // Set max to current time (forecast button will extend if needed)
                    const maxTime = predictionVisible ? new Date(now.getTime() + (24 * 60 * 60 * 1000)) : now;
                    debugChartInstance.options.scales.x.max = maxTime;
                    debugChartInstance.options.plugins.zoom.limits.x.max = maxTime;
                    debugChartInstance.update();
                }
            });
            
            document.getElementById('show72Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const seventyTwoHoursAgo = new Date(now.getTime() - (72 * 60 * 60 * 1000));
                    debugChartInstance.options.scales.x.min = seventyTwoHoursAgo;
                    
                    // Set max to current time (forecast button will extend if needed)
                    const maxTime = predictionVisible ? new Date(now.getTime() + (24 * 60 * 60 * 1000)) : now;
                    debugChartInstance.options.scales.x.max = maxTime;
                    debugChartInstance.options.plugins.zoom.limits.x.max = maxTime;
                    debugChartInstance.update();
                }
            });
        });
    </script>
</body>
</html>