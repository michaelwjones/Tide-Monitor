<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://tide-monitor-boron-default-rtdb.firebaseio.com data:;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tide Monitor - Debug Dashboard</title>
    <style>
        .hidden {
            display: none;
        }
        .main-link {
            background: #28a745;
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            display: inline-block;
        }
        .main-link:hover {
            background: #218838;
            color: white;
            text-decoration: none;
        }
        .toggle-prediction {
            background: #17a2b8;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            cursor: pointer;
            margin-left: 10px;
        }
        .toggle-prediction:hover {
            background: #138496;
        }
        .toggle-prediction.active {
            background: #fd7e14;
        }
        .toggle-prediction.active:hover {
            background: #e8650f;
        }
        .toggle-trendlines {
            background: #007bff;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            cursor: pointer;
            margin-left: 10px;
        }
        .toggle-trendlines:hover {
            background: #0056b3;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body>
    
    <h1>Tide Monitor - Debug Dashboard</h1>
    
    <div id="loading">Loading...</div>
    
    <div id="content" class="hidden">
        <canvas id="debugChart" width="800" height="600"></canvas>
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 10px;">
            <div style="display: flex; align-items: center;">
                <a href="../index.html" class="main-link">‚Üê Main Dashboard</a>
                <button id="togglePrediction" class="toggle-prediction hidden">Show Forecast</button>
                <button id="show24Hours" class="toggle-trendlines" style="background: #007bff; margin-left: 10px;">24 Hours</button>
                <button id="show72Hours" class="toggle-trendlines" style="background: #6c757d; margin-left: 5px;">72 Hours</button>
            </div>
            <div id="chartLegend" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-size: 14px; flex: 1;"></div>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            fetchDebugData();
            
            // Auto-refresh every 2 minutes (120,000 milliseconds)
            setInterval(fetchDebugData, 120000);
        });

        let debugChartInstance = null;
        let predictionVisible = false;
        let currentReadings = [];

        async function fetchDebugData() {
            try {
                console.log('Fetching debug data...');
                
                // Fetch last 4320 readings (72 hours)
                const response = await fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/readings.json?orderBy="$key"&limitToLast=4320');
                const data = await response.json();
                
                if (!data) {
                    document.getElementById('loading').textContent = 'No data available';
                    return;
                }

                // Convert Firebase data to array with all measurements
                const allReadings = Object.entries(data).map(([key, value]) => ({
                    timestamp: new Date(value.t),
                    rawTimestamp: new Date(value.t),
                    waterLevel: (value.w / 304.8).toFixed(2), // Convert mm to feet
                    waterLevelRaw: value.w / 304.8,
                    waveHeightPercentile: value.hp ? (value.hp / 304.8).toFixed(2) : '--',
                    waveHeightPercentileRaw: value.hp ? value.hp / 304.8 : null,
                    waveHeightEnvelope: value.he ? (value.he / 304.8).toFixed(2) : '--',
                    waveHeightEnvelopeRaw: value.he ? value.he / 304.8 : null,
                    waterLevelPercentile: value.wp ? (value.wp / 304.8).toFixed(2) : '--',
                    waterLevelPercentileRaw: value.wp ? value.wp / 304.8 : null,
                    waterLevelEnvelope: value.we ? (value.we / 304.8).toFixed(2) : '--',
                    waterLevelEnvelopeRaw: value.we ? value.we / 304.8 : null,
                    validSamples: value.vs || '--',
                    validSamplesRaw: value.vs || 0,
                    windSpeed: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944).toFixed(1) : '--',
                    windSpeedRaw: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944) : null,
                    windDirection: (value.wd !== undefined && value.wd !== null && value.wd !== "-999") ? parseFloat(value.wd).toFixed(0) : '--',
                    gustSpeed: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944).toFixed(1) : '--',
                    gustSpeedRaw: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944) : null,
                    dukeWaterLevel: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm).toFixed(2) : '--',
                    dukeWaterLevelRaw: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm) : null
                }));
                
                // Store readings for chart display
                currentReadings = allReadings;
                
                // Check for transformer forecast availability
                const transformerData = await fetchTransformerPredictions();
                if (transformerData) {
                    document.getElementById('togglePrediction').classList.remove('hidden');
                } else {
                    document.getElementById('togglePrediction').classList.add('hidden');
                }
                
                // Create debug chart
                createDebugChart(allReadings);
                
                // Hide loading and show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');
            } catch (error) {
                console.error('Error fetching debug data:', error);
                document.getElementById('loading').textContent = 'Error loading data. Check console for details.';
            }
        }

        // Fetch Transformer 24-hour forecasts from Firebase
        async function fetchTransformerPredictions() {
            try {
                const response = await fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/tidal-analysis/transformer-v1-forecast.json');
                const data = await response.json();
                
                if (!data || !data.forecast) {
                    console.log('No Transformer forecasts found');
                    return null;
                }
                
                // Check if forecast was updated in the last 10 minutes
                const generatedAt = new Date(data.generated_at);
                const now = new Date();
                const timeDiff = (now - generatedAt) / (1000 * 60); // minutes
                
                if (timeDiff > 10) {
                    console.log(`Transformer forecast is ${timeDiff.toFixed(1)} minutes old, not showing`);
                    return null;
                }
                
                console.log(`Fetched Transformer forecast: ${data.forecast.length} predictions`);
                
                // Each prediction has: timestamp (ISO string), prediction (mm), step
                const predictions = data.forecast.map(pred => ({
                    timestamp: new Date(pred.timestamp),
                    prediction: pred.prediction, // Keep in mm
                    step: pred.step
                }));
                
                return {
                    predictions: predictions,
                    generatedAt: generatedAt,
                    modelVersion: data.model_version,
                    inputDataCount: data.input_data_count
                };
                
            } catch (error) {
                console.error('Error fetching Transformer predictions:', error);
                return null;
            }
        }

        function createDebugChart(readings) {
            // Destroy existing chart if it exists
            if (debugChartInstance) {
                debugChartInstance.destroy();
            }
            
            const ctx = document.getElementById('debugChart').getContext('2d');

            // Set initial time range to last 24 hours
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));

            debugChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        {
                            label: 'Water Level (Average)',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.waterLevelRaw })),
                            borderColor: '#007bff',
                            backgroundColor: '#007bff20',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-water'
                        },
                        {
                            label: 'Water Level (Percentile)',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.waterLevelPercentileRaw })).filter(p => p.y !== null),
                            borderColor: '#17a2b8',
                            backgroundColor: '#17a2b820',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-water'
                        },
                        {
                            label: 'Water Level (Envelope)',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.waterLevelEnvelopeRaw })).filter(p => p.y !== null),
                            borderColor: '#dc3545',
                            backgroundColor: '#dc354520',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-water'
                        },
                        {
                            label: 'Wave Height (Percentile)',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.waveHeightPercentileRaw })).filter(p => p.y !== null),
                            borderColor: '#fd7e14',
                            backgroundColor: '#fd7e1420',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-wave'
                        },
                        {
                            label: 'Wave Height (Envelope)',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.waveHeightEnvelopeRaw })).filter(p => p.y !== null),
                            borderColor: '#e83e8c',
                            backgroundColor: '#e83e8c20',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-wave'
                        },
                        {
                            label: 'Valid Samples',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.validSamplesRaw })),
                            borderColor: '#6c757d',
                            backgroundColor: '#6c757d20',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-samples',
                            hidden: true
                        },
                        {
                            label: 'Wind Speed',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.windSpeedRaw })).filter(p => p.y !== null),
                            borderColor: '#28a745',
                            backgroundColor: '#28a74520',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-wind'
                        },
                        {
                            label: 'Gust Speed',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.gustSpeedRaw })).filter(p => p.y !== null),
                            borderColor: '#155724',
                            backgroundColor: '#15572420',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-wind'
                        },
                        {
                            label: 'Duke Water Level',
                            data: readings.map(r => ({ x: r.rawTimestamp, y: r.dukeWaterLevelRaw })).filter(p => p.y !== null),
                            borderColor: '#004085',
                            backgroundColor: '#00408520',
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0,
                            pointHoverRadius: 2,
                            yAxisID: 'y-water'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                timezone: 'America/New_York'
                            },
                            min: twentyFourHoursAgo,
                            max: now,
                            title: {
                                display: true,
                                text: 'Time (Eastern)'
                            }
                        },
                        'y-water': {
                            type: 'linear',
                            position: 'left',
                            min: 0,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Water Level (feet)'
                            },
                            grid: {
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        'y-wave': {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 2,
                            title: {
                                display: true,
                                text: 'Wave Height (feet)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        'y-wind': {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 30,
                            title: {
                                display: true,
                                text: 'Wind Speed (knots)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        'y-samples': {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 512,
                            display: false
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    modifierKey: 'ctrl'
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(54, 162, 235, 0.2)'
                                },
                                mode: 'x',
                                onZoomComplete: function({chart}) {
                                    chart.update('none');
                                }
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {
                                    min: readings[0]?.rawTimestamp || twentyFourHoursAgo,
                                    max: now
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    }
                },
                plugins: [Chart.zoomPlugin]
            });

            // Create custom legend
            createCustomLegend();
        }

        function createCustomLegend() {
            const legendContainer = document.getElementById('chartLegend');
            if (!debugChartInstance) return;

            const legendItems = [
                { label: 'Water Level (Average)', color: '#007bff' },
                { label: 'Water Level (Percentile)', color: '#17a2b8' },
                { label: 'Water Level (Envelope)', color: '#dc3545' },
                { label: 'Wave Height (Percentile)', color: '#fd7e14' },
                { label: 'Wave Height (Envelope)', color: '#e83e8c' },
                { label: 'Wind Speed', color: '#28a745' },
                { label: 'Gust Speed', color: '#155724' },
                { label: 'Duke Water Level', color: '#004085' }
            ];

            legendContainer.innerHTML = legendItems.map(item => `
                <div style="display: flex; align-items: center;">
                    <div style="width: 20px; height: 3px; background-color: ${item.color}; margin-right: 8px;"></div>
                    <span>${item.label}</span>
                </div>
            `).join('');
        }

        // Add Transformer predictions to the chart
        async function addTransformerPredictions() {
            const forecastData = await fetchTransformerPredictions();
            
            if (!forecastData || !debugChartInstance) {
                return;
            }
            
            // Convert predictions to chart data (water level in feet, points only)
            const predictionData = forecastData.predictions.map(pred => ({
                x: pred.timestamp,
                y: pred.prediction / 304.8 // Convert mm to feet
            }));
            
            // Add prediction dataset to chart (points only, no connecting lines)
            const predictionDataset = {
                label: 'Transformer 24h Forecast',
                data: predictionData,
                borderColor: '#FF6B35',
                backgroundColor: '#FF6B35',
                fill: false,
                showLine: false, // Don't connect points with lines
                pointRadius: 3,
                pointHoverRadius: 5,
                yAxisID: 'y-water'
            };
            
            // Add dataset to chart
            debugChartInstance.data.datasets.push(predictionDataset);
            debugChartInstance.update('none');
            
            console.log(`Added Transformer predictions: ${predictionData.length} points`);
        }

        // Remove Transformer predictions from the chart
        function removeTransformerPredictions() {
            if (!debugChartInstance) return;
            
            // Find and remove Transformer prediction dataset
            debugChartInstance.data.datasets = debugChartInstance.data.datasets.filter(
                dataset => dataset.label !== 'Transformer 24h Forecast'
            );
            debugChartInstance.update('none');
            
            console.log('Removed Transformer predictions from chart');
        }

        // Toggle 24-hour prediction visibility
        async function togglePrediction() {
            predictionVisible = !predictionVisible;
            
            const button = document.getElementById('togglePrediction');
            if (predictionVisible) {
                button.textContent = 'Hide Forecast';
                button.classList.add('active');
                
                // Add Transformer predictions to the chart
                await addTransformerPredictions();
                
                // Extend chart x-axis to show 24 hours into future for prediction
                if (debugChartInstance) {
                    const currentMax = debugChartInstance.options.scales.x.max;
                    const extendedMax = new Date(currentMax.getTime() + (24 * 60 * 60 * 1000)); // Add 24 hours
                    debugChartInstance.options.scales.x.max = extendedMax;
                    
                    // Also update zoom limits to allow viewing the prediction
                    debugChartInstance.options.plugins.zoom.limits.x.max = extendedMax;
                    debugChartInstance.update('none'); // Update without animation for smooth transition
                }
            } else {
                button.textContent = 'Show Forecast';
                button.classList.remove('active');
                
                // Remove Transformer predictions from chart
                removeTransformerPredictions();
                
                // Reset chart x-axis to current time (remove future prediction view)
                if (debugChartInstance) {
                    const now = new Date();
                    debugChartInstance.options.scales.x.max = now;
                    
                    // Reset zoom limits to current time
                    debugChartInstance.options.plugins.zoom.limits.x.max = now;
                    debugChartInstance.update('none'); // Update without animation for smooth transition
                }
            }
        }

        // Initialize event listeners
        window.addEventListener('load', function() {
            document.getElementById('togglePrediction').addEventListener('click', togglePrediction);
            
            document.getElementById('show24Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                    debugChartInstance.options.scales.x.min = twentyFourHoursAgo;
                    
                    // If prediction is visible, extend max to show 24 hours of prediction
                    if (predictionVisible) {
                        const extendedMax = new Date(now.getTime() + (24 * 60 * 60 * 1000));
                        debugChartInstance.options.scales.x.max = extendedMax;
                        debugChartInstance.options.plugins.zoom.limits.x.max = extendedMax;
                    } else {
                        debugChartInstance.options.scales.x.max = now;
                        debugChartInstance.options.plugins.zoom.limits.x.max = now;
                    }
                    debugChartInstance.update();
                }
            });
            
            document.getElementById('show72Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const seventyTwoHoursAgo = new Date(now.getTime() - (72 * 60 * 60 * 1000));
                    debugChartInstance.options.scales.x.min = seventyTwoHoursAgo;
                    
                    // If prediction is visible, extend max to show 24 hours of prediction
                    if (predictionVisible) {
                        const extendedMax = new Date(now.getTime() + (24 * 60 * 60 * 1000));
                        debugChartInstance.options.scales.x.max = extendedMax;
                        debugChartInstance.options.plugins.zoom.limits.x.max = extendedMax;
                    } else {
                        debugChartInstance.options.scales.x.max = now;
                        debugChartInstance.options.plugins.zoom.limits.x.max = now;
                    }
                    debugChartInstance.update();
                }
            });
        });
    </script>
</body>
</html>