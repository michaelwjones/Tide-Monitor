<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://tide-monitor-boron-default-rtdb.firebaseio.com data:;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tide Monitor - Debug Dashboard</title>
    <style>
        .hidden {
            display: none;
        }
        .main-link {
            background: #28a745;
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            display: inline-block;
        }
        .main-link:hover {
            background: #218838;
            color: white;
            text-decoration: none;
        }
        .toggle-trendlines {
            background: #007bff;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            cursor: pointer;
            margin-left: 10px;
        }
        .toggle-trendlines:hover {
            background: #0056b3;
        }
        #debugChart {
            max-height: 600px;
            width: 100%;
        }
        .wind-direction-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }
        .wind-arrow {
            width: 2px;
            height: 25px;
            background: purple;
            position: relative;
            transform-origin: center bottom;
        }
        .wind-arrow::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            width: 0;
            height: 0;
            border-left: 4px solid transparent;
            border-right: 4px solid transparent;
            border-bottom: 8px solid purple;
        }
        .chart-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body>
    
    <h1>Tide Monitor - Debug Dashboard</h1>
    
    <div id="loading">Loading...</div>
    
    <div id="content" class="hidden">
        <div class="chart-container">
            <canvas id="debugChart" width="800" height="500"></canvas>
            <div id="windDirectionIndicator" class="wind-direction-indicator" style="display: none;">
                <div class="wind-arrow" id="windArrow"></div>
            </div>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 10px;">
            <div id="chartLegend" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-size: 14px; flex: 1;"></div>
            <div style="display: flex; align-items: center;">
                <a href="../index.html" class="main-link">← Main Dashboard</a>
                <button id="show24Hours" class="toggle-trendlines" style="background: #007bff; margin-left: 10px;">24 Hours</button>
                <button id="show72Hours" class="toggle-trendlines" style="background: #6c757d; margin-left: 5px;">72 Hours</button>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            fetchDebugData();
            
            // Auto-refresh every 2 minutes (120,000 milliseconds)
            setInterval(fetchDebugData, 120000);
        });

        let debugChartInstance = null;
        let currentReadings = [];
        let forecastData = null;

        // Round wind direction to nearest 22.5 degrees (16 compass directions)
        function roundWindDirection(degrees) {
            if (degrees === null || degrees === undefined || isNaN(degrees)) return null;
            return Math.round(degrees / 22.5) * 22.5;
        }

        // Update wind direction indicator
        function updateWindDirectionIndicator(readings) {
            const indicator = document.getElementById('windDirectionIndicator');
            const arrow = document.getElementById('windArrow');
            
            if (!readings || readings.length === 0 || !debugChartInstance) {
                indicator.style.display = 'none';
                return;
            }
            
            // Get the most recent wind direction and speed readings
            const latestReading = readings[readings.length - 1];
            const windDirection = latestReading.windDirection;
            const windSpeed = latestReading.windSpeedRaw;
            
            if (windDirection === '--' || windDirection === null || windDirection === undefined ||
                windSpeed === null || windSpeed === undefined) {
                indicator.style.display = 'none';
                return;
            }
            
            // Find the wind speed dataset
            const windSpeedDataset = debugChartInstance.data.datasets.find(ds => ds.label === 'Wind Speed (knots)');
            if (!windSpeedDataset || windSpeedDataset.data.length === 0) {
                indicator.style.display = 'none';
                return;
            }
            
            // Get the latest wind speed data point
            const latestWindData = windSpeedDataset.data[windSpeedDataset.data.length - 1];
            if (!latestWindData) {
                indicator.style.display = 'none';
                return;
            }
            
            // Get chart dimensions and scales
            const chartArea = debugChartInstance.chartArea;
            const xScale = debugChartInstance.scales.x;
            const yScale = debugChartInstance.scales.windSpeed;
            
            // Calculate pixel position of the latest wind speed point
            const pixelX = xScale.getPixelForValue(latestWindData.x);
            const pixelY = yScale.getPixelForValue(latestWindData.y);
            
            // Position indicator so the arrow BASE starts at the wind plot endpoint
            // Arrow is 25px tall, so we need to offset the container so the bottom of the arrow is at the endpoint
            indicator.style.left = `${pixelX - 1}px`; // Center the 2px wide arrow
            indicator.style.top = `${pixelY - 25}px`; // Position so bottom of arrow is at the endpoint
            
            // Round to nearest 22.5 degrees
            const roundedDirection = roundWindDirection(parseFloat(windDirection));
            
            // Rotate arrow to point in wind direction (0° = North = up)
            arrow.style.transform = `rotate(${roundedDirection}deg)`;
            
            // Show the indicator
            indicator.style.display = 'block';
            
            // Update tooltip with direction info
            indicator.title = `Wind Direction: ${roundedDirection}°`;
        }

        async function fetchDebugData() {
            try {
                console.log('Fetching debug data...');
                
                // Fetch last 4320 readings (72 hours)
                const response = await fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/readings.json?orderBy="$key"&limitToLast=4320');
                const data = await response.json();
                
                if (!data) {
                    document.getElementById('loading').textContent = 'No data available';
                    return;
                }

                // Convert Firebase data to array with all measurements
                const allReadings = Object.entries(data).map(([key, value]) => ({
                    timestamp: new Date(value.t),
                    rawTimestamp: new Date(value.t),
                    waterLevel: (value.w / 304.8).toFixed(2), // Convert mm to feet
                    waterLevelRaw: value.w / 304.8,
                    waveHeightPercentile: value.hp ? (value.hp / 304.8).toFixed(2) : '--',
                    waveHeightPercentileRaw: value.hp ? value.hp / 304.8 : null,
                    waveHeightEnvelope: value.he ? (value.he / 304.8).toFixed(2) : '--',
                    waveHeightEnvelopeRaw: value.he ? value.he / 304.8 : null,
                    waterLevelPercentile: value.wp ? (value.wp / 304.8).toFixed(2) : '--',
                    waterLevelPercentileRaw: value.wp ? value.wp / 304.8 : null,
                    waterLevelEnvelope: value.we ? (value.we / 304.8).toFixed(2) : '--',
                    waterLevelEnvelopeRaw: value.we ? value.we / 304.8 : null,
                    validSamples: value.vs || '--',
                    validSamplesRaw: value.vs || 0,
                    windSpeed: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944).toFixed(1) : '--',
                    windSpeedRaw: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944) : null,
                    windDirection: (value.wd !== undefined && value.wd !== null && value.wd !== "-999") ? parseFloat(value.wd).toFixed(0) : '--',
                    gustSpeed: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944).toFixed(1) : '--',
                    gustSpeedRaw: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944) : null,
                    dukeWaterLevel: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm).toFixed(2) : '--',
                    dukeWaterLevelRaw: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm) : null
                }));
                
                // Store readings for chart display
                currentReadings = allReadings;
                
                // Check for transformer forecast availability
                forecastData = await fetchTransformerPredictions();
                
                // Create debug chart
                createDebugChart(allReadings);
                
                // Update wind direction indicator
                updateWindDirectionIndicator(allReadings);
                
                // Hide loading and show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');
            } catch (error) {
                console.error('Error fetching debug data:', error);
                document.getElementById('loading').textContent = 'Error loading data. Check console for details.';
            }
        }

        // Fetch Transformer 24-hour forecasts from Firebase
        async function fetchTransformerPredictions() {
            try {
                // Try v2 first, then fallback to v1
                const sources = [
                    { url: 'https://tide-monitor-boron-default-rtdb.firebaseio.com/tidal-analysis/transformer-v2-forecast.json', version: 'v2' },
                    { url: 'https://tide-monitor-boron-default-rtdb.firebaseio.com/tidal-analysis/transformer-v1-forecast.json', version: 'v1' }
                ];
                
                for (const source of sources) {
                    try {
                        const response = await fetch(source.url);
                        const data = await response.json();
                        
                        if (!data || !data.forecast) {
                            console.log(`No Transformer ${source.version} forecasts found`);
                            continue;
                        }
                        
                        // Check if forecast was updated in the last 10 minutes
                        const generatedAt = new Date(data.generated_at);
                        const now = new Date();
                        const timeDiff = (now - generatedAt) / (1000 * 60); // minutes
                        
                        if (timeDiff > 10) {
                            console.log(`Transformer ${source.version} forecast is ${timeDiff.toFixed(1)} minutes old, not showing`);
                            continue;
                        }
                        
                        console.log(`Fetched Transformer ${source.version} forecast: ${data.forecast.length} predictions`);
                        
                        // Each prediction has: timestamp (ISO string), prediction (mm), step
                        const predictions = data.forecast.map(pred => ({
                            timestamp: new Date(pred.timestamp),
                            prediction: pred.prediction, // Keep in mm
                            step: pred.step
                        }));
                        
                        return {
                            predictions: predictions,
                            generatedAt: generatedAt,
                            modelVersion: data.model_version,
                            inputDataCount: data.input_data_count,
                            version: source.version
                        };
                        
                    } catch (error) {
                        console.log(`Error fetching Transformer ${source.version} predictions:`, error);
                        continue;
                    }
                }
                
                console.log('No recent Transformer forecasts found');
                return null;
                
            } catch (error) {
                console.error('Error fetching Transformer predictions:', error);
                return null;
            }
        }

        function createDebugChart(readings) {
            // Destroy existing chart if it exists
            if (debugChartInstance) {
                debugChartInstance.destroy();
            }
            
            const ctx = document.getElementById('debugChart').getContext('2d');

            // Set initial time range to last 24 hours, extend if forecast available
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            const maxTime = forecastData ? new Date(now.getTime() + (24 * 60 * 60 * 1000)) : now;

            debugChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Water Level (ft)',
                        data: readings.map(r => ({x: r.rawTimestamp, y: r.waterLevelRaw})),
                        borderColor: 'blue',
                        backgroundColor: 'rgba(0, 0, 255, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.6,
                        order: 1
                    }, {
                        label: 'Waves (ft)',
                        data: readings.map(r => ({x: r.rawTimestamp, y: r.waveHeightPercentileRaw})).filter(p => p.y !== null),
                        borderColor: 'red',
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.5,
                        order: 2,
                        yAxisID: 'waveHeight'
                    }, {
                        label: 'Wind Speed (knots)',
                        data: readings.map(r => ({x: r.rawTimestamp, y: r.windSpeedRaw})).filter(p => p.y !== null),
                        borderColor: 'purple',
                        backgroundColor: 'rgba(128, 0, 128, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.5,
                        order: 3,
                        yAxisID: 'windSpeed'
                    }, {
                        label: 'Duke Water Level',
                        data: readings.map(r => ({x: r.rawTimestamp, y: r.dukeWaterLevelRaw})).filter(p => p.y !== null),
                        borderColor: 'darkblue',
                        backgroundColor: 'rgba(0, 0, 139, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.6,
                        order: 4
                    }, {
                        label: 'Reference Line',
                        data: [{x: twentyFourHoursAgo, y: 3}, {x: maxTime, y: 3}],
                        borderColor: 'green',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        fill: false,
                        tension: 0,
                        order: 0
                    }]
                },
                options: {
                    animation: false,
                    responsive: true,
                    scales: {
                        y: {
                            min: 0,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Water Level (feet)'
                            },
                            position: 'left'
                        },
                        waveHeight: {
                            type: 'linear',
                            min: 0,
                            max: 1,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Wave Height (feet)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        windSpeed: {
                            type: 'linear',
                            min: 0,
                            max: 40,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Wind Speed (knots)'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            offset: true
                        },
                        x: {
                            type: 'time',
                            min: twentyFourHoursAgo,
                            max: maxTime,
                            time: {
                                displayFormats: {
                                    hour: 'h:mm a'
                                }
                            },
                            title: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false
                        }
                    }
                }
            });

            // Add forecast data if available
            if (forecastData) {
                addTransformerPredictionsToChart();
            }
            
            // Create custom legend
            createCustomLegend();
            
            // Update wind direction indicator after chart is fully rendered
            setTimeout(() => updateWindDirectionIndicator(currentReadings), 100);
        }

        function createCustomLegend() {
            const legendContainer = document.getElementById('chartLegend');
            if (!debugChartInstance) return;

            const legendItems = [
                { label: 'Water Level (ft)', color: 'blue' },
                { label: 'Waves (ft)', color: 'red' },
                { label: 'Wind Speed (knots)', color: 'purple' },
                { label: 'Duke Water Level', color: 'darkblue' },
                { label: 'Reference Line', color: 'green' }
            ];

            // Add forecast legend item if forecast data is available
            if (forecastData) {
                legendItems.push({ 
                    label: `Transformer ${forecastData.version.toUpperCase()} 24h Forecast`, 
                    color: 'purple',
                    isPoints: true
                });
            }

            legendContainer.innerHTML = legendItems.map(item => `
                <span style="display: flex; align-items: center; gap: 5px;">
                    ${item.isPoints ? 
                        `<span style="width: 8px; height: 8px; background-color: ${item.color}; border-radius: 50%; display: inline-block;"></span>` :
                        `<span style="width: 16px; height: 3px; background-color: ${item.color}; display: inline-block;"></span>`
                    }
                    <span>${item.label}</span>
                </span>
            `).join('');
        }

        // Add Transformer predictions to the chart using existing forecast data
        function addTransformerPredictionsToChart() {
            if (!forecastData || !debugChartInstance) {
                return;
            }
            
            // Convert predictions to chart data (water level in feet, points only)
            const predictionData = forecastData.predictions.map(pred => ({
                x: pred.timestamp,
                y: pred.prediction / 304.8 // Convert mm to feet
            }));
            
            // Add prediction dataset to chart (points only, no connecting lines)
            const predictionDataset = {
                label: `Transformer ${forecastData.version.toUpperCase()} 24h Forecast`,
                data: predictionData,
                borderColor: 'purple',
                backgroundColor: 'purple',
                fill: false,
                showLine: false, // Don't connect points with lines
                pointRadius: 3,
                pointHoverRadius: 5,
                yAxisID: 'y'
            };
            
            // Add dataset to chart
            debugChartInstance.data.datasets.push(predictionDataset);
            debugChartInstance.update('none');
            
            console.log(`Added Transformer predictions: ${predictionData.length} points`);
        }

        // Add Transformer predictions to the chart (legacy function for compatibility)
        async function addTransformerPredictions() {
            const newForecastData = await fetchTransformerPredictions();
            
            if (!newForecastData || !debugChartInstance) {
                return;
            }
            
            forecastData = newForecastData;
            addTransformerPredictionsToChart();
        }

        // Remove Transformer predictions from the chart
        function removeTransformerPredictions() {
            if (!debugChartInstance) return;
            
            // Find and remove Transformer prediction dataset
            debugChartInstance.data.datasets = debugChartInstance.data.datasets.filter(
                dataset => !dataset.label.includes('Transformer') || !dataset.label.includes('24h Forecast')
            );
            debugChartInstance.update('none');
            
            console.log('Removed Transformer predictions from chart');
        }


        // Initialize event listeners
        window.addEventListener('load', function() {
            
            document.getElementById('show24Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                    debugChartInstance.options.scales.x.min = twentyFourHoursAgo;
                    
                    // Set max to current time, extend if forecast data available
                    const maxTime = forecastData ? new Date(now.getTime() + (24 * 60 * 60 * 1000)) : now;
                    debugChartInstance.options.scales.x.max = maxTime;
                    if (debugChartInstance.options.plugins.zoom && debugChartInstance.options.plugins.zoom.limits) {
                        debugChartInstance.options.plugins.zoom.limits.x.max = maxTime;
                    }
                    debugChartInstance.update();
                    
                    // Update wind direction indicator after chart update
                    setTimeout(() => updateWindDirectionIndicator(currentReadings), 100);
                }
            });
            
            document.getElementById('show72Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const seventyTwoHoursAgo = new Date(now.getTime() - (72 * 60 * 60 * 1000));
                    debugChartInstance.options.scales.x.min = seventyTwoHoursAgo;
                    
                    // Set max to current time, extend if forecast data available
                    const maxTime = forecastData ? new Date(now.getTime() + (24 * 60 * 60 * 1000)) : now;
                    debugChartInstance.options.scales.x.max = maxTime;
                    if (debugChartInstance.options.plugins.zoom && debugChartInstance.options.plugins.zoom.limits) {
                        debugChartInstance.options.plugins.zoom.limits.x.max = maxTime;
                    }
                    debugChartInstance.update();
                    
                    // Update wind direction indicator after chart update
                    setTimeout(() => updateWindDirectionIndicator(currentReadings), 100);
                }
            });
        });
    </script>
</body>
</html>