<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://tide-monitor-boron-default-rtdb.firebaseio.com data:;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tide Monitor - Debug Dashboard</title>
    <style>
        .hidden {
            display: none;
        }
        .main-link {
            background: #28a745;
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            display: inline-block;
        }
        .main-link:hover {
            background: #218838;
            color: white;
            text-decoration: none;
        }
        .toggle-trendlines {
            background: #007bff;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            cursor: pointer;
            margin-left: 10px;
        }
        .toggle-trendlines:hover {
            background: #0056b3;
        }
        .toggle-trendlines.active {
            background: #28a745;
        }
        .toggle-trendlines.active:hover {
            background: #218838;
        }
        .tidal-analysis-table {
            margin-top: 20px;
            border-collapse: collapse;
            width: 100%;
            max-width: 600px;
        }
        .tidal-analysis-table th,
        .tidal-analysis-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        .tidal-analysis-table th {
            background-color: #f5f5f5;
            font-weight: 600;
        }
        .tidal-analysis-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body>
    
    <h1>Tide Monitor - Debug Dashboard</h1>
    
    <div id="loading">Loading...</div>
    
    <div id="content" class="hidden">
        <canvas id="debugChart" width="800" height="600"></canvas>
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 10px;">
            <div style="display: flex; align-items: center;">
                <a href="../index.html" class="main-link">← Main Dashboard</a>
                <button id="toggleTrendlines" class="toggle-trendlines">Show Trend Lines</button>
                <button id="show24Hours" class="toggle-trendlines" style="background: #007bff; margin-left: 10px;">24 Hours</button>
                <button id="show72Hours" class="toggle-trendlines" style="background: #6c757d; margin-left: 5px;">72 Hours</button>
            </div>
            <div id="chartLegend" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-size: 14px; flex: 1;"></div>
        </div>
        
        <div style="margin-top: 20px;">
            <h3>Detected Tidal Frequencies (Matrix Pencil Analysis)</h3>
            <table id="tidalAnalysisTable" class="tidal-analysis-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Period (hours)</th>
                        <th>Frequency (cycles/day)</th>
                        <th>Amplitude</th>
                        <th>Damping (1/s)</th>
                        <th>Component Type</th>
                    </tr>
                </thead>
                <tbody id="tidalAnalysisBody">
                    <tr>
                        <td colspan="6" style="text-align: center; color: #666;">Loading signal analysis...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            fetchDebugData();
            
            // Auto-refresh every 2 minutes (120,000 milliseconds)
            setInterval(fetchDebugData, 120000);
        });

        let debugChartInstance = null;
        let trendLinesVisible = false;
        let currentReadings = [];
        let detectedTidalFrequencies = null;
        let cachedMatrixPencilResults = null; // Cache Matrix Pencil analysis results

        // Prepare data for cubic spline interpolation with light smoothing (Wind/Wave category)
        function prepareWindWaveSplineData(data) {
            const n = data.length;
            if (n < 4) return null;
            
            // Sort data by x value and remove duplicates
            const sortedData = [...data].sort((a, b) => a.x.getTime() - b.x.getTime());
            const uniqueData = [];
            
            for (let i = 0; i < sortedData.length; i++) {
                if (i === 0 || sortedData[i].x.getTime() !== sortedData[i-1].x.getTime()) {
                    uniqueData.push(sortedData[i]);
                }
            }
            
            if (uniqueData.length < 4) return null;
            
            // Apply progressive smoothing with up to 30-point moving average
            const lightlySmoothed = [];
            for (let i = 0; i < uniqueData.length; i++) {
                // Determine smoothing window size based on distance from edges
                const distFromStart = i;
                const distFromEnd = uniqueData.length - 1 - i;
                const maxRadius = Math.min(distFromStart, distFromEnd);
                
                // Progressive smoothing: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 30 point averages
                const windowSizes = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 30];
                const radius = Math.min(maxRadius, Math.floor((windowSizes.length - 1)));
                const windowSize = windowSizes[radius];
                const halfWindow = Math.floor(windowSize / 2);
                
                // Calculate moving average
                let sum = 0;
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    sum += uniqueData[i + j].y;
                }
                const smoothedY = sum / windowSize;
                
                lightlySmoothed.push({
                    x: uniqueData[i].x,
                    y: smoothedY
                });
            }
            
            return {
                data: lightlySmoothed,
                type: 'cubic_spline'
            };
        }
        
        // Natural cubic spline computation using Thomas algorithm (O(n) complexity) for Wind/Wave category
        function computeWindWaveNaturalCubicSpline(data) {
            const n = data.length;
            if (n < 4) return null;
            
            const x = data.map(d => d.x.getTime());
            const y = data.map(d => d.y);
            
            // Calculate intervals
            const h = new Array(n - 1);
            for (let i = 0; i < n - 1; i++) {
                h[i] = x[i + 1] - x[i];
                if (h[i] === 0) return null; // Avoid division by zero
            }
            
            // Set up the tridiagonal system for natural spline
            const alpha = new Array(n - 1);
            for (let i = 1; i < n - 1; i++) {
                alpha[i] = (3 / h[i]) * (y[i + 1] - y[i]) - (3 / h[i - 1]) * (y[i] - y[i - 1]);
            }
            
            // Solve tridiagonal system using Thomas algorithm
            const l = new Array(n);
            const mu = new Array(n);
            const z = new Array(n);
            
            l[0] = 1;
            mu[0] = 0;
            z[0] = 0;
            
            for (let i = 1; i < n - 1; i++) {
                l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * mu[i - 1];
                mu[i] = h[i] / l[i];
                z[i] = (alpha[i] - h[i - 1] * z[i - 1]) / l[i];
            }
            
            l[n - 1] = 1;
            z[n - 1] = 0;
            
            // Back substitution
            const c = new Array(n);
            c[n - 1] = 0;
            
            for (let j = n - 2; j >= 0; j--) {
                c[j] = z[j] - mu[j] * c[j + 1];
            }
            
            // Calculate spline coefficients
            const a = new Array(n);
            const b = new Array(n);
            const d = new Array(n);
            
            for (let i = 0; i < n - 1; i++) {
                a[i] = y[i];
                b[i] = (y[i + 1] - y[i]) / h[i] - h[i] * (c[i + 1] + 2 * c[i]) / 3;
                d[i] = (c[i + 1] - c[i]) / (3 * h[i]);
            }
            
            return {
                x: x,
                a: a,
                b: b,
                c: c,
                d: d,
                n: n
            };
        }
        
        // Evaluate cubic spline at given x values for Wind/Wave category
        function evaluateWindWaveCubicSpline(spline, xValues) {
            const points = [];
            
            for (const targetX of xValues) {
                const x = targetX.getTime();
                
                // Find the interval containing x
                let i = 0;
                while (i < spline.n - 1 && x > spline.x[i + 1]) {
                    i++;
                }
                
                // Clamp to valid range
                i = Math.max(0, Math.min(i, spline.n - 2));
                
                const dx = x - spline.x[i];
                const y = spline.a[i] + spline.b[i] * dx + spline.c[i] * dx * dx + spline.d[i] * dx * dx * dx;
                
                points.push({
                    x: targetX,
                    y: y
                });
            }
            
            return points;
        }

        // Generate tight-fitting trend line data points using cubic splines for Wind/Wave category
        function generateWindWaveTrendLine(data, splineData) {
            if (!splineData || !splineData.data || splineData.data.length < 4) return [];
            
            // Compute natural cubic spline directly from the data
            const spline = computeWindWaveNaturalCubicSpline(splineData.data);
            if (!spline) return [];
            
            // Generate evaluation points for smooth curve
            const firstTime = splineData.data[0].x.getTime();
            const lastTime = splineData.data[splineData.data.length - 1].x.getTime();
            const timeRange = lastTime - firstTime;
            
            const evalPoints = [];
            const numPoints = Math.min(200, splineData.data.length * 3); // More points for tighter curves
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const currentTime = firstTime + t * timeRange;
                evalPoints.push(new Date(currentTime));
            }
            
            // Evaluate spline at these points
            return evaluateWindWaveCubicSpline(spline, evalPoints);
        }

        // Matrix Pencil Method for signal parameter estimation
        // Decomposes signal into complex exponentials: y(t) = Σ Aₖ e^(sₖt) where sₖ = σₖ + jωₖ
        
        // SVD computation for Matrix Pencil
        function computeSVD(matrix) {
            const m = matrix.length;
            const n = matrix[0].length;
            
            // Simple power iteration SVD for our use case
            // For production, would use more robust algorithm
            const tolerance = 1e-6; // Relaxed tolerance for speed
            const maxIterations = 50; // Much fewer iterations for web browser
            
            const U = [];
            const S = [];
            const Vt = [];
            
            // Create copy of matrix for decomposition
            let A = matrix.map(row => [...row]);
            
            const rank = Math.min(m, n, 5); // Limit to first 5 singular values for speed
            
            for (let k = 0; k < rank; k++) {
                // Power iteration to find dominant singular value/vector
                let v = new Array(n).fill(0).map(() => Math.random() - 0.5);
                let prevSigma = 0;
                
                for (let iter = 0; iter < maxIterations; iter++) {
                    // v = A^T * A * v
                    const Av = new Array(m).fill(0);
                    for (let i = 0; i < m; i++) {
                        for (let j = 0; j < n; j++) {
                            Av[i] += A[i][j] * v[j];
                        }
                    }
                    
                    const AtAv = new Array(n).fill(0);
                    for (let j = 0; j < n; j++) {
                        for (let i = 0; i < m; i++) {
                            AtAv[j] += A[i][j] * Av[i];
                        }
                    }
                    
                    // Normalize
                    const norm = Math.sqrt(AtAv.reduce((sum, val) => sum + val * val, 0));
                    if (norm < tolerance) break;
                    
                    for (let j = 0; j < n; j++) {
                        v[j] = AtAv[j] / norm;
                    }
                    
                    // Calculate singular value
                    const sigma = Math.sqrt(norm);
                    
                    if (Math.abs(sigma - prevSigma) < tolerance) break;
                    prevSigma = sigma;
                }
                
                // Calculate u = A * v / sigma
                const Av = new Array(m).fill(0);
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += A[i][j] * v[j];
                    }
                }
                
                const sigma = Math.sqrt(Av.reduce((sum, val) => sum + val * val, 0));
                if (sigma < tolerance) break;
                
                const u = Av.map(val => val / sigma);
                
                // Store singular vectors and value
                U.push(u);
                S.push(sigma);
                Vt.push([...v]);
                
                // Deflate matrix: A = A - σ * u * v^T
                for (let i = 0; i < m; i++) {
                    for (let j = 0; j < n; j++) {
                        A[i][j] -= sigma * u[i] * v[j];
                    }
                }
            }
            
            return { U, S, Vt };
        }


        // TEMPORARY: Simple fallback for testing - just return a mock tidal frequency
        function simpleTidalAnalysis(data) {
            const n = data.length;
            const y = data.map(d => d.y);
            const mean = y.reduce((sum, val) => sum + val, 0) / n;
            
            // Mock M2 tidal component (12.42 hours)
            const mockComponent = {
                frequency: 2 * Math.PI / (12.42 * 3600), // rad/sec
                periodMs: 12.42 * 60 * 60 * 1000,
                periodHours: 12.42,
                damping: -1e-6, // Slight decay
                amplitude: 0.5, // 0.5 feet amplitude
                phase: 0.0,
                eigenvalue: { real: 0.99, imag: 0.1 },
                power: 0.25
            };
            
            return {
                components: [mockComponent],
                dcComponent: mean,
                startTime: data[0].x.getTime(),
                samplingInterval: 60, // 1 minute
                modelOrder: 2,
                pencilParam: 10,
                dataLength: n
            };
        }
        
        // Matrix Pencil Method - Signal parameter estimation for non-periodic data
        // Estimates frequencies, damping, amplitudes, and phases from time series data
        function matrixPencilAnalysis(data, pencilParam = null) {
            const n = data.length;
            if (n < 20) return null; // Need sufficient data for Matrix Pencil
            
            const sn = data.length;
            const x = data.map(d => d.x.getTime());
            const y = data.map(d => d.y);
            
            console.log(`Matrix Pencil: Processing ${sn} samples`);
            
            // Calculate sampling parameters (assume regular intervals)
            const timeSpanMs = x[x.length - 1] - x[0];
            const timeSpanSec = timeSpanMs / 1000;
            const samplingInterval = timeSpanSec / (sn - 1);
            const startTime = x[0];
            
            // Remove DC component
            const mean = y.reduce((sum, val) => sum + val, 0) / sn;
            const yDetrended = y.map(val => val - mean);
            
            // Set pencil parameter L for proper tidal frequency resolution
            const L = Math.min(pencilParam || Math.floor(sn / 3), Math.floor(sn / 2)); // Use up to half the samples
            const M = sn - L + 1;
            
            console.log(`Matrix Pencil: L=${L}, M=${M}`);
            
            // Construct Hankel data matrix Y0 (M x L)
            const Y0 = [];
            for (let i = 0; i < M; i++) {
                const row = [];
                for (let j = 0; j < L; j++) {
                    row.push(yDetrended[i + j]);
                }
                Y0.push(row);
            }
            
            // Construct shifted Hankel matrix Y1 (M x L)
            const Y1 = [];
            for (let i = 0; i < M - 1; i++) {
                const row = [];
                for (let j = 0; j < L; j++) {
                    row.push(yDetrended[i + j + 1]);
                }
                Y1.push(row);
            }
            
            // SVD of Y0 to determine signal subspace
            console.log(`Matrix Pencil: Computing SVD of ${M}x${L} matrix`);
            let svd;
            svd = computeSVD(Y0);
            if (!svd || !svd.S || svd.S.length === 0) {
                throw new Error('SVD computation failed - no singular values returned');
            }
            console.log(`Matrix Pencil: SVD completed, ${svd.S.length} singular values`);
            
            // Determine model order using SVD threshold (keep components > 1% of max singular value)
            const threshold = 0.01 * Math.max(...svd.S);
            let modelOrder = 0;
            for (let i = 0; i < svd.S.length; i++) {
                if (svd.S[i] > threshold) {
                    modelOrder++;
                } else {
                    break;
                }
            }
            
            // Ensure we have at least 2 components for complex eigenvalue, but not too many
            modelOrder = Math.max(2, Math.min(modelOrder, 8));
            console.log(`Matrix Pencil: Determined model order = ${modelOrder} from ${svd.S.length} singular values`);
            console.log('Singular values:', svd.S);
            
            if (svd.S.length < modelOrder) {
                throw new Error(`Insufficient singular values: need ${modelOrder}, have ${svd.S.length}`);
            }
            
            // Extract signal subspace (first modelOrder columns of U and Vt)
            const Us = svd.U.slice(0, modelOrder);
            const Vs = svd.Vt.slice(0, modelOrder);
            
            // Form V1 (first L-1 columns) and V2 (last L-1 columns) - transpose of Vs submatrices
            const V1 = [];
            const V2 = [];
            
            // V1 and V2 should be (L-1) x modelOrder matrices
            for (let i = 0; i < L - 1; i++) {
                const v1Row = [];
                const v2Row = [];
                for (let j = 0; j < modelOrder; j++) {
                    v1Row.push(Vs[j][i]);     // First L-1 elements
                    v2Row.push(Vs[j][i + 1]); // Last L-1 elements (shifted by 1)
                }
                V1.push(v1Row);
                V2.push(v2Row);
            }
            
            console.log(`Matrix Pencil: V1 size = ${V1.length} x ${V1[0].length}, V2 size = ${V2.length} x ${V2[0].length}`);
            
            // Solve generalized eigenvalue problem: V1 * z = λ * V2 * z
            // Simplified approach: use V1^† * V2 for eigenvalue computation
            console.log(`Matrix Pencil: Computing eigenvalues`);
            let eigenvalues;
            eigenvalues = solveGeneralizedEigenvalue(V1, V2);
            if (!eigenvalues || eigenvalues.length === 0) {
                throw new Error('Eigenvalue computation failed - no eigenvalues returned');
            }
            console.log(`Matrix Pencil: Found ${eigenvalues.length} eigenvalues`);
            console.log('Eigenvalues:', eigenvalues);
            
            // Extract signal parameters from eigenvalues - TEMPORARILY limit to 1 component
            const signalComponents = [];
            
            // Process eigenvalues to detect tidal frequencies, keeping only positive frequencies
            for (let k = 0; k < eigenvalues.length; k++) {
                const lambda = eigenvalues[k];
                const magnitude = Math.sqrt((lambda.real || 0) * (lambda.real || 0) + (lambda.imag || 0) * (lambda.imag || 0));
                
                // Skip eigenvalues that are too small or exactly 1 (DC component)
                if (magnitude < 1e-6 || Math.abs(magnitude - 1.0) < 1e-6) {
                    continue;
                }
                
                // Only process eigenvalues with positive imaginary part to avoid conjugate duplicates
                if ((lambda.imag || 0) <= 0) {
                    continue;
                }
                
                // Convert eigenvalue to continuous-time parameters
                const lambdaMag = Math.sqrt((lambda.real || 0) * (lambda.real || 0) + (lambda.imag || 0) * (lambda.imag || 0));
                const s_real = Math.log(lambdaMag) / samplingInterval; // Damping (σ)
                const s_imag = Math.atan2(lambda.imag || 0, lambda.real || 0) / samplingInterval; // Frequency (ω)
                
                console.log(`Eigenvalue processing: lambdaMag=${lambdaMag}, s_real=${s_real}, s_imag=${s_imag}`);
                
                const frequency = Math.abs(s_imag);
                if (frequency > 1e-6) {
                    const periodSec = (2 * Math.PI) / frequency;
                    const periodMs = periodSec * 1000;
                    const periodHours = periodMs / (60 * 60 * 1000);
                    
                    // Estimate amplitude and phase using least squares fitting
                    const amplitude = estimateAmplitudePhase(x, yDetrended, s_real, s_imag, startTime, samplingInterval);
                    const phase = amplitude ? amplitude.phase : 0;
                    const amplitudeMag = amplitude ? amplitude.magnitude : 0;
                    const dampingCoeff = s_real;
                    
                    console.log(`Component analysis: frequency=${frequency.toFixed(6)}, s_real=${s_real.toFixed(6)}, s_imag=${s_imag.toFixed(6)}, amplitudeMag=${amplitudeMag}`);
                    
                    signalComponents.push({
                        frequency: frequency,         // rad/sec
                        periodMs: periodMs,
                        periodHours: periodHours,
                        damping: dampingCoeff,        // damping coefficient (σ)
                        amplitude: amplitudeMag,      // complex amplitude magnitude
                        phase: phase,                 // phase in radians
                        eigenvalue: lambda,           // original eigenvalue
                        power: amplitudeMag * amplitudeMag  // power measure for sorting
                    });
                }
            }
            
            // Sort by power (amplitude squared)
            signalComponents.sort((a, b) => b.power - a.power);
            
            // Output results to console
            console.log('Matrix Pencil Analysis Results:');
            console.log(`Model Order: ${modelOrder}, Pencil Parameter L: ${L}, Data Length: ${n}`);
            console.log(`Found ${signalComponents.length} signal components:`);
            signalComponents.forEach((comp, index) => {
                console.log(`Component ${index + 1}: Period=${comp.periodHours.toFixed(2)}h, Frequency=${comp.frequency.toFixed(6)} rad/s, Amplitude=${comp.amplitude.toFixed(4)}, Damping=${comp.damping.toFixed(6)}`);
            });
            
            return {
                components: signalComponents,
                dcComponent: mean,
                startTime: startTime,
                samplingInterval: samplingInterval,
                modelOrder: modelOrder,
                pencilParam: L,
                dataLength: n
            };
        }
        
        // Matrix operations utilities
        function matrixMultiply(A, B) {
            const m = A.length;
            const n = A[0].length;
            const p = B[0].length;
            
            if (n !== B.length) {
                throw new Error('Matrix dimensions incompatible for multiplication');
            }
            
            const result = [];
            for (let i = 0; i < m; i++) {
                result[i] = [];
                for (let j = 0; j < p; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    result[i][j] = sum;
                }
            }
            return result;
        }
        
        function matrixTranspose(A) {
            const m = A.length;
            const n = A[0].length;
            const result = [];
            
            for (let j = 0; j < n; j++) {
                result[j] = [];
                for (let i = 0; i < m; i++) {
                    result[j][i] = A[i][j];
                }
            }
            return result;
        }
        
        function matrixInverse(A) {
            const n = A.length;
            
            // Create augmented matrix [A | I]
            const augmented = [];
            for (let i = 0; i < n; i++) {
                augmented[i] = [...A[i]];
                for (let j = 0; j < n; j++) {
                    augmented[i][n + j] = (i === j) ? 1 : 0;
                }
            }
            
            // Gaussian elimination with partial pivoting
            for (let i = 0; i < n; i++) {
                // Find pivot
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                
                // Swap rows
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                
                // Check for singular matrix
                if (Math.abs(augmented[i][i]) < 1e-12) {
                    throw new Error(`Matrix is singular or near-singular at row ${i}`);
                }
                
                // Scale pivot row
                const pivot = augmented[i][i];
                for (let j = 0; j < 2 * n; j++) {
                    augmented[i][j] /= pivot;
                }
                
                // Eliminate column
                for (let k = 0; k < n; k++) {
                    if (k !== i) {
                        const factor = augmented[k][i];
                        for (let j = 0; j < 2 * n; j++) {
                            augmented[k][j] -= factor * augmented[i][j];
                        }
                    }
                }
            }
            
            // Extract inverse matrix
            const inverse = [];
            for (let i = 0; i < n; i++) {
                inverse[i] = augmented[i].slice(n);
            }
            
            return inverse;
        }
        
        // QR decomposition using Gram-Schmidt process
        function qrDecomposition(A) {
            const m = A.length;
            const n = A[0].length;
            
            const Q = [];
            const R = [];
            
            // Initialize Q with zeros
            for (let i = 0; i < m; i++) {
                Q[i] = new Array(n).fill(0);
            }
            
            // Initialize R with zeros
            for (let i = 0; i < n; i++) {
                R[i] = new Array(n).fill(0);
            }
            
            // Gram-Schmidt process
            for (let j = 0; j < n; j++) {
                // Get column j of A
                const v = [];
                for (let i = 0; i < m; i++) {
                    v[i] = A[i][j];
                }
                
                // Orthogonalize against previous columns
                for (let k = 0; k < j; k++) {
                    // Compute R[k][j] = Q_k^T * v
                    let dot = 0;
                    for (let i = 0; i < m; i++) {
                        dot += Q[i][k] * v[i];
                    }
                    R[k][j] = dot;
                    
                    // v = v - R[k][j] * Q_k
                    for (let i = 0; i < m; i++) {
                        v[i] -= R[k][j] * Q[i][k];
                    }
                }
                
                // Compute R[j][j] = ||v||
                let norm = 0;
                for (let i = 0; i < m; i++) {
                    norm += v[i] * v[i];
                }
                R[j][j] = Math.sqrt(norm);
                
                // Check for linear dependence
                if (R[j][j] < 1e-12) {
                    throw new Error(`Matrix is rank deficient at column ${j}`);
                }
                
                // Q_j = v / ||v||
                for (let i = 0; i < m; i++) {
                    Q[i][j] = v[i] / R[j][j];
                }
            }
            
            return { Q, R };
        }
        
        // Solve generalized eigenvalue problem for Matrix Pencil using QZ algorithm approximation
        function solveGeneralizedEigenvalue(V1, V2) {
            if (!V1 || !V2 || V1.length === 0 || V2.length === 0) return [];
            
            const m = V1.length;  // model order
            const n = V1[0].length; // L - 1
            
            try {
                // Convert to standard eigenvalue problem: solve V1^+ * V2
                // where V1^+ is the Moore-Penrose pseudoinverse of V1
                
                // Compute V1^T
                const V1T = matrixTranspose(V1);
                
                // Compute V1^T * V1
                const V1TV1 = matrixMultiply(V1T, V1);
                
                // Check condition number of V1TV1 before inversion
                const condition = checkConditionNumber(V1TV1);
                console.log('V1TV1 condition number:', condition);
                console.log('V1TV1 matrix size:', V1TV1.length, 'x', V1TV1[0].length);
                
                if (condition > 1e12) {
                    throw new Error(`V1TV1 matrix is too ill-conditioned: condition number = ${condition}`);
                }
                
                // Compute (V1^T * V1)^(-1)
                const V1TV1_inv = matrixInverse(V1TV1);
                if (!V1TV1_inv) {
                    throw new Error('Failed to invert V1^T * V1 - matrix is singular');
                }
                console.log('V1TV1_inv successful');
                
                // Compute V1^+ = (V1^T * V1)^(-1) * V1^T
                const V1_pinv = matrixMultiply(V1TV1_inv, V1T);
                
                // Compute C = V1^+ * V2 (companion-like matrix)
                const C = matrixMultiply(V1_pinv, V2);
                
                // Now solve eigenvalue problem for C using QR algorithm
                const eigenvalues = solveEigenvalues(C);
                
                return eigenvalues;
                
            } catch (error) {
                throw new Error(`Generalized eigenvalue computation failed: ${error.message}`);
            }
        }
        
        // QR algorithm for eigenvalue computation
        function solveEigenvalues(A) {
            const n = A.length;
            const maxIterations = 20; // Much fewer iterations
            const tolerance = 1e-4; // Relaxed tolerance
            
            // Make a copy of A
            let Ak = A.map(row => [...row]);
            
            for (let iter = 0; iter < maxIterations; iter++) {
                // QR decomposition
                const qr = qrDecomposition(Ak);
                if (!qr) break;
                
                // Ak+1 = R * Q
                Ak = matrixMultiply(qr.R, qr.Q);
                
                // Check for convergence (off-diagonal elements should be small)
                let offDiagNorm = 0;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            offDiagNorm += Ak[i][j] * Ak[i][j];
                        }
                    }
                }
                
                if (Math.sqrt(offDiagNorm) < tolerance) {
                    break;
                }
            }
            
            // Extract eigenvalues from diagonal
            const eigenvalues = [];
            for (let i = 0; i < n; i++) {
                // For real matrices, eigenvalues can be complex
                // Check for 2x2 blocks on diagonal for complex eigenvalues
                if (i < n - 1 && Math.abs(Ak[i + 1][i]) > tolerance) {
                    // 2x2 block - complex eigenvalues
                    const a = Ak[i][i];
                    const b = Ak[i][i + 1];
                    const c = Ak[i + 1][i];
                    const d = Ak[i + 1][i + 1];
                    
                    const trace = a + d;
                    const det = a * d - b * c;
                    const discriminant = trace * trace - 4 * det;
                    
                    if (discriminant < 0) {
                        // Complex eigenvalues
                        const realPart = trace / 2;
                        const imagPart = Math.sqrt(-discriminant) / 2;
                        
                        eigenvalues.push({
                            real: realPart,
                            imag: imagPart
                        });
                        eigenvalues.push({
                            real: realPart,
                            imag: -imagPart
                        });
                        
                        i++; // Skip next diagonal element
                    } else {
                        // Real eigenvalue from this position
                        eigenvalues.push({
                            real: Ak[i][i],
                            imag: 0
                        });
                    }
                } else {
                    // Real eigenvalue
                    eigenvalues.push({
                        real: Ak[i][i],
                        imag: 0
                    });
                }
            }
            
            return eigenvalues;
        }
        
        // Check condition number of a matrix (rough estimate)
        function checkConditionNumber(A) {
            const n = A.length;
            
            // Simple condition number estimate: ||A|| * ||A^-1||
            // For a rough check, we'll just look at the diagonal elements
            let maxDiag = 0;
            let minDiag = Infinity;
            
            for (let i = 0; i < n; i++) {
                const diag = Math.abs(A[i][i]);
                maxDiag = Math.max(maxDiag, diag);
                minDiag = Math.min(minDiag, diag);
            }
            
            if (minDiag === 0) return Infinity;
            return maxDiag / minDiag;
        }
        
        // Estimate amplitude and phase for a given frequency component
        function estimateAmplitudePhase(timeValues, dataValues, damping, frequency, startTime, samplingInterval) {
            const n = dataValues.length;
            
            // Check for valid inputs
            if (!isFinite(damping) || !isFinite(frequency) || frequency === 0) {
                console.log('Invalid parameters for amplitude estimation: damping=', damping, 'frequency=', frequency);
                return null;
            }
            
            // Build design matrix for least squares: [cos(ωt)e^(σt), sin(ωt)e^(σt)]
            const A = [];
            const b = [];
            
            for (let i = 0; i < n; i++) {
                const t = i * samplingInterval; // Time from start in seconds
                const expDamping = Math.exp(damping * t);
                
                // Check for numerical issues
                if (!isFinite(expDamping)) {
                    console.log('Exponential damping overflow at t=', t, 'damping=', damping);
                    return null;
                }
                
                const cosComponent = Math.cos(frequency * t) * expDamping;
                const sinComponent = Math.sin(frequency * t) * expDamping;
                
                A.push([cosComponent, sinComponent]);
                b.push(dataValues[i]);
            }
            
            // Solve least squares: [a, b] = (A^T A)^(-1) A^T y
            try {
                const AT = matrixTranspose(A);
                const ATA = matrixMultiply(AT, A);
                const ATA_inv = matrixInverse(ATA);
                
                if (!ATA_inv) {
                    throw new Error('Matrix inversion failed in amplitude estimation');
                }
                
                const ATb = [];
                for (let i = 0; i < 2; i++) {
                    let sum = 0;
                    for (let j = 0; j < n; j++) {
                        sum += AT[i][j] * b[j];
                    }
                    ATb.push(sum);
                }
                
                const coeffs = [];
                for (let i = 0; i < 2; i++) {
                    let sum = 0;
                    for (let j = 0; j < 2; j++) {
                        sum += ATA_inv[i][j] * ATb[j];
                    }
                    coeffs.push(sum);
                }
                
                const a = coeffs[0]; // Cosine coefficient
                const b_coeff = coeffs[1]; // Sine coefficient
                
                // Convert to magnitude and phase: A*cos(ωt + φ) = a*cos(ωt) + b*sin(ωt)
                const magnitude = Math.sqrt(a * a + b_coeff * b_coeff);
                const phase = Math.atan2(-b_coeff, a); // Phase shift
                
                return { magnitude, phase };
                
            } catch (error) {
                throw new Error(`Amplitude/phase estimation failed: ${error.message}`);
            }
        }

        
        // Solve linear system Ax = b using Gaussian elimination with partial pivoting
        function solveLinearSystem(A, b) {
            const n = A.length;
            const augmented = [];
            
            // Create augmented matrix
            for (let i = 0; i < n; i++) {
                augmented[i] = [...A[i], b[i]];
            }
            
            // Forward elimination with partial pivoting
            for (let i = 0; i < n; i++) {
                // Find pivot
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                
                // Swap rows
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
                
                // Check for singular matrix
                if (Math.abs(augmented[i][i]) < 1e-12) {
                    console.warn('Singular or near-singular matrix detected in harmonic fitting');
                    return null;
                }
                
                // Eliminate column
                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }
            
            // Back substitution
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }
            
            return x;
        }

        // Compute signal components using Matrix Pencil analysis
        function computeWaterLevelComponents(data, forceRecompute = false) {
            const n = data.length;
            if (n < 20) return null; // Need sufficient data for Matrix Pencil
            
            // Use cached results if available and not forcing recompute
            if (cachedMatrixPencilResults && !forceRecompute) {
                console.log('Using cached Matrix Pencil results');
                return cachedMatrixPencilResults;
            }
            
            // Perform Matrix Pencil analysis
            console.log('Computing Matrix Pencil analysis...');
            const pencilResult = matrixPencilAnalysis(data);
            if (!pencilResult || !pencilResult.components || pencilResult.components.length === 0) {
                console.warn('Matrix Pencil analysis failed to detect signal components - skipping trends');
                return null;
            }
            
            // Store components for table display and update table immediately
            detectedTidalFrequencies = pencilResult.components;
            updateTidalAnalysisTable(pencilResult.components);
            
            // Cache and return Matrix Pencil results for trend line reconstruction
            const results = {
                dcComponent: pencilResult.dcComponent,
                components: pencilResult.components,
                startTime: pencilResult.startTime,
                samplingInterval: pencilResult.samplingInterval,
                modelOrder: pencilResult.modelOrder,
                pencilParam: pencilResult.pencilParam,
                dataLength: pencilResult.dataLength,
                primaryPeriod: pencilResult.components[0]?.periodMs || 24 * 60 * 60 * 1000,
                primaryPeriodHours: pencilResult.components[0]?.periodHours || 24,
                primaryPower: pencilResult.components[0]?.power || 0
            };
            
            // Cache the results for future use
            cachedMatrixPencilResults = results;
            
            return results;
        }
        
        // Evaluate Matrix Pencil signal reconstruction: Σ Aₖ e^(sₖt) where sₖ = σₖ + jωₖ
        // Can evaluate anywhere - no periodicity assumptions
        function evaluateMatrixPencilReconstruction(pencilData, xValues) {
            const points = [];
            
            for (const targetX of xValues) {
                const t = (targetX.getTime() - pencilData.startTime) / 1000; // seconds from start
                
                // Start with DC component
                let y = pencilData.dcComponent;
                
                // Add all signal components: Aₖ e^(σₖt) cos(ωₖt + φₖ)
                for (const component of pencilData.components) {
                    const dampedAmplitude = component.amplitude * Math.exp(component.damping * t);
                    y += dampedAmplitude * Math.cos(component.frequency * t + component.phase);
                }
                
                points.push({
                    x: targetX,
                    y: y
                });
            }
            
            return points;
        }
        
        // Generate Matrix Pencil trend line data points for Water Level category
        function generateWaterLevelTrendLine(displayData, analysisData) {
            if (!analysisData || analysisData.length < 20) return [];
            
            // Compute Matrix Pencil components from analysis data
            const pencilResult = computeWaterLevelComponents(analysisData);
            if (!pencilResult) return [];
            
            // Generate evaluation points for smooth curve over full chart display range
            const firstTime = displayData[0].x.getTime();
            const lastTime = displayData[displayData.length - 1].x.getTime();
            const timeRange = lastTime - firstTime;
            
            const evalPoints = [];
            const numPoints = 200; // Sufficient resolution for smooth curves
            
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                const currentTime = firstTime + t * timeRange;
                evalPoints.push(new Date(currentTime));
            }
            
            // Evaluate Matrix Pencil reconstruction at these points
            return evaluateMatrixPencilReconstruction(pencilResult, evalPoints);
        }

        async function fetchDebugData() {
            try {
                // Clear cached Matrix Pencil results when fetching new data
                cachedMatrixPencilResults = null;
                
                // Fetch full 72 hours of data for display and analysis
                const response = await fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/readings/.json?orderBy="$key"&limitToLast=4320');
                const data = await response.json();
                
                // Define time ranges
                const now = new Date();
                const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                
                // Convert all data for FFT analysis (72 hours)
                const allReadings = Object.entries(data).map(([key, value]) => ({
                    id: key,
                    timestamp: new Date(value.t).toLocaleString('en-US', { 
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    }),
                    rawTimestamp: new Date(value.t),
                    waterLevel: (value.w / 304.8).toFixed(2),
                    wavesPercentile: (value.hp !== undefined && value.hp !== null) ? (value.hp / 304.8).toFixed(2) : '--',
                    wavesEnvelope: (value.he !== undefined && value.he !== null) ? (value.he / 304.8).toFixed(2) : '--',
                    waterLevelPercentile: (value.wp !== undefined && value.wp !== null) ? (value.wp / 304.8).toFixed(2) : '--',
                    waterLevelEnvelope: (value.we !== undefined && value.we !== null) ? (value.we / 304.8).toFixed(2) : '--',
                    validSamples: value.vs || '--',
                    validSamplesRaw: value.vs || 0,
                    // NOAA data from Duke Marine Lab
                    dukeWaterLevel: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm).toFixed(2) : '--',
                    dukeWaterLevelRaw: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm) : null,
                    windSpeed: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944).toFixed(1) : '--', // Convert m/s to knots
                    windSpeedRaw: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944) : null,
                    gustSpeed: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944).toFixed(1) : '--', // Convert m/s to knots
                    gustSpeedRaw: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944) : null
                }));
                
                // Store all readings for both FFT analysis and chart display
                currentReadings = allReadings;  // Full 72hr dataset for analysis and display
                
                // Create debug chart with full 72hr data
                createDebugChart(allReadings);
                
                // Hide loading and show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');
                
                // Run automatic tidal analysis for table (async, after chart is displayed)
                setTimeout(() => {
                    performTidalAnalysis(allReadings);
                }, 0);
            } catch (error) {
                console.error('Error fetching debug data:', error);
                document.getElementById('loading').textContent = 'Error loading data. Check console for details.';
            }
        }

        function createDebugChart(readings) {
            // Destroy existing chart if it exists
            if (debugChartInstance) {
                debugChartInstance.destroy();
            }
            
            const ctx = document.getElementById('debugChart').getContext('2d');
            
            // Filter out any invalid timestamps
            const validReadings = readings.filter(r => r.rawTimestamp.getTime() > 0);
            
            // Set time range - default display 24 hours, but allow zoom to 72 hours
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            const seventyTwoHoursAgo = new Date(now.getTime() - (72 * 60 * 60 * 1000));
            
            
            debugChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Water Level (Average)',
                        data: validReadings.map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevel)})),
                        borderColor: 'rgba(0, 0, 255, 1)',
                        backgroundColor: 'rgba(0, 0, 255, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 1
                    }, {
                        label: 'Water Level (Percentile)',
                        data: validReadings.filter(r => r.waterLevelPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevelPercentile)})),
                        borderColor: 'rgba(0, 255, 255, 1)',
                        backgroundColor: 'rgba(0, 255, 255, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 2
                    }, {
                        label: 'Water Level (Envelope)',
                        data: validReadings.filter(r => r.waterLevelEnvelope !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevelEnvelope)})),
                        borderColor: 'rgba(255, 0, 255, 1)',
                        backgroundColor: 'rgba(255, 0, 255, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 3
                    }, {
                        label: 'Wave Height (Percentile)',
                        data: validReadings.filter(r => r.wavesPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesPercentile)})),
                        borderColor: 'rgba(255, 0, 0, 1)',
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y1',
                        order: 5
                    }, {
                        label: 'Wave Height (Envelope)',
                        data: validReadings.filter(r => r.wavesEnvelope !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesEnvelope)})),
                        borderColor: 'rgba(255, 165, 0, 1)',
                        backgroundColor: 'rgba(255, 165, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y1',
                        order: 6
                    }, {
                        label: 'Valid Samples',
                        data: validReadings.map(r => ({x: r.rawTimestamp, y: r.validSamplesRaw})),
                        borderColor: 'rgba(128, 128, 128, 1)',
                        backgroundColor: 'rgba(128, 128, 128, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y2',
                        order: 8
                    }, {
                        label: 'Duke Marine Lab Water Level',
                        data: validReadings.filter(r => r.dukeWaterLevelRaw !== null).map(r => ({x: r.rawTimestamp, y: r.dukeWaterLevelRaw + 1.2})),
                        borderColor: 'rgba(0, 0, 139, 1)',
                        backgroundColor: 'rgba(0, 0, 139, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 0,
                        borderDash: [5, 5]
                    }, {
                        label: 'Wind Speed',
                        data: validReadings.filter(r => r.windSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.windSpeedRaw})),
                        borderColor: 'rgba(0, 128, 0, 1)',
                        backgroundColor: 'rgba(0, 128, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y3',
                        order: 9
                    }, {
                        label: 'Gust Speed',
                        data: validReadings.filter(r => r.gustSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.gustSpeedRaw})),
                        borderColor: 'rgba(0, 100, 0, 1)',
                        backgroundColor: 'rgba(0, 100, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y3',
                        order: 10,
                        borderDash: [3, 3]
                    }]
                },
                options: {
                    animation: false,
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            min: 0,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Water Level (feet)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 2,
                            title: {
                                display: true,
                                text: 'Wave Height (feet)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 512,
                            display: false,
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        y3: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 40,
                            title: {
                                display: true,
                                text: 'Wind Speed (knots)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        x: {
                            type: 'time',
                            min: twentyFourHoursAgo,
                            max: now,
                            time: {
                                displayFormats: {
                                    hour: 'h:mm a'
                                }
                            },
                            title: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false
                        },
                        zoom: {
                            limits: {
                                x: {
                                    min: seventyTwoHoursAgo,
                                    max: now
                                }
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                    modifierKey: 'ctrl'
                                },
                                drag: {
                                    enabled: true,
                                    backgroundColor: 'rgba(225,225,225,0.3)',
                                    borderColor: 'rgba(225,225,225,1)',
                                    borderWidth: 1
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x',
                                scaleMode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x',
                                scaleMode: 'x'
                            }
                        }
                    }
                }
            });
            
            // Generate custom legend
            const legendContainer = document.getElementById('chartLegend');
            if (legendContainer) {
                const legendItems = [
                    { label: 'Water Level (Average)', color: 'blue' },
                    { label: 'Duke Marine Lab Water Level', color: 'darkblue', dash: true },
                    { label: 'Water Level (Percentile)', color: 'cyan' },
                    { label: 'Water Level (Envelope)', color: 'magenta' },
                    { label: 'Wave Height (Percentile)', color: 'red' },
                    { label: 'Wave Height (Envelope)', color: 'orange' },
                    { label: 'Wind Speed', color: 'green' },
                    { label: 'Gust Speed', color: 'darkgreen', dot: true },
                    { label: 'Valid Samples', color: 'gray' }
                ];
                
                legendContainer.innerHTML = legendItems.map(item => `
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 16px; height: 3px; background-color: ${item.color}; display: inline-block; ${item.dash ? 'background-image: repeating-linear-gradient(to right, ' + item.color + ' 0px, ' + item.color + ' 2px, transparent 2px, transparent 4px);' : item.dot ? 'background-image: repeating-linear-gradient(to right, ' + item.color + ' 0px, ' + item.color + ' 1px, transparent 1px, transparent 3px);' : ''}"></span>
                        <span>${item.label}</span>
                    </span>
                `).join('');
            }
            
            // Add trend lines if enabled
            if (trendLinesVisible) {
                addTrendLines();
            }
        }

        // Add water level trend lines using harmonics
        function addWaterLevelTrendLines() {
            if (!debugChartInstance || !currentReadings.length) return;
            
            // Use full 72hr dataset for both FFT analysis and display
            const allValidReadings = currentReadings.filter(r => r.rawTimestamp.getTime() > 0);
            
            // Use all data for display (full 72 hours)
            const displayReadings = allValidReadings;
            
            // Water level dataset indices: 0, 1, 2, 6
            const waterLevelIndices = [0, 1, 2, 6];
            
            // Reduce opacity of water level datasets
            debugChartInstance.data.datasets.forEach((dataset, index) => {
                if (waterLevelIndices.includes(index)) {
                    dataset.borderColor = dataset.borderColor.replace(/rgba\(([^,]+),\s*([^,]+),\s*([^,]+),\s*[^)]+\)/, (match, r, g, b) => {
                        return `rgba(${r}, ${g}, ${b}, 0.3)`;
                    });
                    dataset.backgroundColor = dataset.backgroundColor.replace(/rgba\(([^,]+),\s*([^,]+),\s*([^,]+),\s*[^)]+\)/, (match, r, g, b) => {
                        return `rgba(${r}, ${g}, ${b}, 0.05)`;
                    });
                }
            });
            
            // Define water level datasets for Matrix Pencil trend lines
            // Use full 72hr data for Matrix Pencil analysis and reconstruction
            // Only calculate trend lines for average water level data
            const waterLevelConfigs = [
                {
                    datasetIndex: 0,
                    label: 'Water Level (Average) - Matrix Pencil',
                    analysisData: allValidReadings.map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevel)})),
                    displayData: displayReadings.map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevel)})),
                    borderColor: 'rgba(0, 0, 255, 0.9)',
                    yAxisID: 'y'
                }
            ];
            
            // Calculate and add Matrix Pencil trend lines
            waterLevelConfigs.forEach(config => {
                if (config.analysisData.length >= 20) { // Need at least 20 points for Matrix Pencil analysis
                    // Generate trend line using Matrix Pencil analysis
                    const trendData = generateWaterLevelTrendLine(config.displayData, config.analysisData);
                    
                    if (trendData && trendData.length > 0) {
                        debugChartInstance.data.datasets.push({
                            label: config.label,
                            data: trendData,
                            borderColor: config.borderColor,
                            backgroundColor: 'transparent',
                            borderWidth: 3,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: config.yAxisID,
                            order: 200 + config.datasetIndex,
                            borderDash: [15, 10]
                        });
                    }
                }
            });
            
            debugChartInstance.update();
        }
        
        // Add wind/wave trend lines using cubic splines
        function addWindWaveTrendLines() {
            if (!debugChartInstance || !currentReadings.length) return;
            
            const validReadings = currentReadings.filter(r => r.rawTimestamp.getTime() > 0);
            
            // Wind/wave dataset indices: 3, 4, 5, 7, 8
            const windWaveIndices = [3, 4, 5, 7, 8];
            
            // Reduce opacity of wind/wave datasets
            debugChartInstance.data.datasets.forEach((dataset, index) => {
                if (windWaveIndices.includes(index)) {
                    dataset.borderColor = dataset.borderColor.replace(/rgba\(([^,]+),\s*([^,]+),\s*([^,]+),\s*[^)]+\)/, (match, r, g, b) => {
                        return `rgba(${r}, ${g}, ${b}, 0.3)`;
                    });
                    dataset.backgroundColor = dataset.backgroundColor.replace(/rgba\(([^,]+),\s*([^,]+),\s*([^,]+),\s*[^)]+\)/, (match, r, g, b) => {
                        return `rgba(${r}, ${g}, ${b}, 0.05)`;
                    });
                }
            });
            
            // Define wind/wave datasets for cubic spline trend lines
            const windWaveConfigs = [
                {
                    datasetIndex: 3,
                    label: 'Wave Height (Percentile) - Spline',
                    data: validReadings.filter(r => r.wavesPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesPercentile)})),
                    borderColor: 'rgba(255, 0, 0, 0.8)',
                    yAxisID: 'y1'
                },
                {
                    datasetIndex: 4,
                    label: 'Wave Height (Envelope) - Spline',
                    data: validReadings.filter(r => r.wavesEnvelope !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesEnvelope)})),
                    borderColor: 'rgba(255, 165, 0, 0.8)',
                    yAxisID: 'y1'
                },
                {
                    datasetIndex: 7,
                    label: 'Wind Speed - Spline',
                    data: validReadings.filter(r => r.windSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.windSpeedRaw})),
                    borderColor: 'rgba(0, 128, 0, 0.8)',
                    yAxisID: 'y3'
                },
                {
                    datasetIndex: 8,
                    label: 'Gust Speed - Spline',
                    data: validReadings.filter(r => r.gustSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.gustSpeedRaw})),
                    borderColor: 'rgba(0, 100, 0, 0.8)',
                    yAxisID: 'y3'
                }
            ];
            
            // Calculate and add cubic spline trend lines
            windWaveConfigs.forEach(config => {
                if (config.data.length >= 4) { // Need at least 4 points for cubic splines
                    const splineData = prepareWindWaveSplineData(config.data);
                    
                    if (splineData) {
                        const trendData = generateWindWaveTrendLine(config.data, splineData);
                        
                        if (trendData && trendData.length > 0) {
                            debugChartInstance.data.datasets.push({
                                label: config.label,
                                data: trendData,
                                borderColor: config.borderColor,
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                yAxisID: config.yAxisID,
                                order: 300 + config.datasetIndex,
                                borderDash: [8, 4]
                            });
                        }
                    } else {
                        console.warn(`Failed to prepare spline data for ${config.label}`);
                    }
                }
            });
            
            debugChartInstance.update();
        }

        // Remove water level trend lines from chart
        function removeWaterLevelTrendLines() {
            if (!debugChartInstance) return;
            
            // Remove water level trend line datasets (those with "Matrix Pencil" in their label)
            debugChartInstance.data.datasets = debugChartInstance.data.datasets.filter(dataset => 
                !dataset.label.includes('Matrix Pencil')
            );
            
            // Restore original opacity for water level datasets
            const waterLevelIndices = [0, 1, 2, 6];
            debugChartInstance.data.datasets.forEach((dataset, index) => {
                if (waterLevelIndices.includes(index)) {
                    // Restore original colors based on dataset type
                    if (dataset.label === 'Water Level (Average)') {
                        dataset.borderColor = 'rgba(0, 0, 255, 1)';
                        dataset.backgroundColor = 'rgba(0, 0, 255, 0.1)';
                    } else if (dataset.label === 'Water Level (Percentile)') {
                        dataset.borderColor = 'rgba(0, 255, 255, 1)';
                        dataset.backgroundColor = 'rgba(0, 255, 255, 0.1)';
                    } else if (dataset.label === 'Water Level (Envelope)') {
                        dataset.borderColor = 'rgba(255, 0, 255, 1)';
                        dataset.backgroundColor = 'rgba(255, 0, 255, 0.1)';
                    } else if (dataset.label === 'Duke Marine Lab Water Level') {
                        dataset.borderColor = 'rgba(0, 0, 139, 1)';
                        dataset.backgroundColor = 'rgba(0, 0, 139, 0.1)';
                    }
                }
            });
            
            debugChartInstance.update();
        }
        
        // Remove wind/wave trend lines from chart
        function removeWindWaveTrendLines() {
            if (!debugChartInstance) return;
            
            // Remove wind/wave trend line datasets (those with "Spline" in their label)
            debugChartInstance.data.datasets = debugChartInstance.data.datasets.filter(dataset => 
                !dataset.label.includes('Spline')
            );
            
            // Restore original opacity for wind/wave datasets
            const windWaveIndices = [3, 4, 5, 7, 8];
            debugChartInstance.data.datasets.forEach((dataset, index) => {
                if (windWaveIndices.includes(index)) {
                    // Restore original colors based on dataset type
                    if (dataset.label === 'Wave Height (Percentile)') {
                        dataset.borderColor = 'rgba(255, 0, 0, 1)';
                        dataset.backgroundColor = 'rgba(255, 0, 0, 0.1)';
                    } else if (dataset.label === 'Wave Height (Envelope)') {
                        dataset.borderColor = 'rgba(255, 165, 0, 1)';
                        dataset.backgroundColor = 'rgba(255, 165, 0, 0.1)';
                    } else if (dataset.label === 'Wind Speed') {
                        dataset.borderColor = 'rgba(0, 128, 0, 1)';
                        dataset.backgroundColor = 'rgba(0, 128, 0, 0.1)';
                    } else if (dataset.label === 'Gust Speed') {
                        dataset.borderColor = 'rgba(0, 100, 0, 1)';
                        dataset.backgroundColor = 'rgba(0, 100, 0, 0.1)';
                    }
                }
            });
            
            debugChartInstance.update();
        }

        // Add all trend lines (both categories using different methods)
        function addTrendLines() {
            addWaterLevelTrendLines();
            addWindWaveTrendLines();
        }
        
        // Remove all trend lines (both categories)
        function removeTrendLines() {
            removeWaterLevelTrendLines();
            removeWindWaveTrendLines();
        }
        
        // Toggle trend lines visibility (unified interface)
        function toggleTrendLines() {
            trendLinesVisible = !trendLinesVisible;
            
            const button = document.getElementById('toggleTrendlines');
            if (trendLinesVisible) {
                button.textContent = 'Hide Trend Lines';
                button.classList.add('active');
                addTrendLines();
            } else {
                button.textContent = 'Show Trend Lines';
                button.classList.remove('active');
                removeTrendLines();
            }
        }

        // Perform automatic tidal analysis for table display using Matrix Pencil
        function performTidalAnalysis(readings) {
            if (!readings || readings.length < 20) {
                updateTidalAnalysisTable(null);
                return;
            }
            
            // Use same data filtering as trend lines for consistency
            const allValidReadings = readings.filter(r => r.rawTimestamp.getTime() > 0);
            
            // Use water level average data for analysis (same as trend lines)
            const waterLevelData = allValidReadings.map(r => ({
                x: r.rawTimestamp,
                y: parseFloat(r.waterLevel)
            })).filter(d => !isNaN(d.y));
            
            if (waterLevelData.length < 20) {
                updateTidalAnalysisTable(null);
                return;
            }
            
            // Run Matrix Pencil analysis that happens in trend lines
            // This will automatically update the table through computeWaterLevelComponents
            const pencilResult = computeWaterLevelComponents(waterLevelData);
            
            // If Matrix Pencil analysis failed, show no results
            if (!pencilResult) {
                updateTidalAnalysisTable(null);
            }
        }
        
        // Update the signal analysis table with Matrix Pencil results
        function updateTidalAnalysisTable(components) {
            const tableBody = document.getElementById('tidalAnalysisBody');
            
            if (!components || components.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #999;">No signal components detected</td></tr>';
                return;
            }
            
            // Clear existing rows
            tableBody.innerHTML = '';
            
            // Add rows for each detected component
            components.forEach((component, index) => {
                const cyclesPerDay = 24 / component.periodHours;
                const tidalType = getTidalType(component.periodHours);
                
                const row = document.createElement('tr');
                const periodMinutes = Math.round(component.periodHours * 60);
                const displayHours = Math.floor(periodMinutes / 60);
                const displayMins = periodMinutes % 60;
                const periodDisplay = displayMins === 0 ? `${displayHours}h` : `${displayHours}h ${displayMins}m`;
                
                // Format damping coefficient (positive = growing, negative = decaying)
                const dampingDisplay = component.damping >= 0 ? 
                    `+${component.damping.toExponential(2)}` : 
                    component.damping.toExponential(2);
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${periodDisplay}</td>
                    <td>${cyclesPerDay.toFixed(3)}</td>
                    <td>${component.amplitude.toFixed(4)}</td>
                    <td>${dampingDisplay}</td>
                    <td>${tidalType}</td>
                `;
                tableBody.appendChild(row);
            });
        }
        
        // Classify tidal type based on period
        function getTidalType(periodHours) {
            if (periodHours >= 23 && periodHours <= 25) {
                return 'Diurnal (O1/K1)';
            } else if (periodHours >= 11.5 && periodHours <= 12.5) {
                return 'Semi-diurnal (M2/S2)';
            } else if (periodHours >= 6 && periodHours <= 8) {
                return 'Quarter-diurnal';
            } else if (periodHours >= 4 && periodHours <= 6) {
                return 'Higher harmonic';
            } else {
                return 'Other';
            }
        }
        
        // Initialize toggle button event listener
        window.addEventListener('load', function() {
            document.getElementById('toggleTrendlines').addEventListener('click', toggleTrendLines);
            document.getElementById('show24Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
                    debugChartInstance.options.scales.x.min = twentyFourHoursAgo;
                    debugChartInstance.options.scales.x.max = now;
                    debugChartInstance.update();
                }
            });
            
            document.getElementById('show72Hours').addEventListener('click', function() {
                if (debugChartInstance) {
                    const now = new Date();
                    const seventyTwoHoursAgo = new Date(now.getTime() - (72 * 60 * 60 * 1000));
                    debugChartInstance.zoomScale('x', {min: seventyTwoHoursAgo, max: now});
                }
            });
        });
    </script>
</body>
</html>