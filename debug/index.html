<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://tide-monitor-boron-default-rtdb.firebaseio.com data:;">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tide Monitor - Debug Dashboard</title>
    <style>
        .hidden {
            display: none;
        }
        .main-link {
            background: #28a745;
            color: white;
            padding: 10px 16px;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            display: inline-block;
        }
        .main-link:hover {
            background: #218838;
            color: white;
            text-decoration: none;
        }
        .toggle-trendlines {
            background: #007bff;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transition: background-color 0.2s;
            cursor: pointer;
            margin-left: 10px;
        }
        .toggle-trendlines:hover {
            background: #0056b3;
        }
        .toggle-trendlines.active {
            background: #28a745;
        }
        .toggle-trendlines.active:hover {
            background: #218838;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    
    <h1>Tide Monitor - Debug Dashboard</h1>
    
    <div id="loading">Loading...</div>
    
    <div id="content" class="hidden">
        <canvas id="debugChart" width="800" height="600"></canvas>
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-top: 10px;">
            <div style="display: flex; align-items: center;">
                <a href="../index.html" class="main-link">‚Üê Main Dashboard</a>
                <button id="toggleTrendlines" class="toggle-trendlines">Show Trend Lines</button>
            </div>
            <div id="chartLegend" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-size: 14px; flex: 1;"></div>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            fetchDebugData();
            
            // Auto-refresh every 2 minutes (120,000 milliseconds)
            setInterval(fetchDebugData, 120000);
        });

        let debugChartInstance = null;
        let trendLinesVisible = false;
        let currentReadings = [];

        // Smooth data using moving average with adjustable window size
        function calculateSmoothTrend(data, windowSize = 0.1) {
            const n = data.length;
            if (n < 3) return null;
            
            // Calculate adaptive window size based on data length
            const adaptiveWindow = Math.max(3, Math.floor(n * windowSize));
            
            // Sort data by x value to ensure proper ordering
            const sortedData = [...data].sort((a, b) => a.x.getTime() - b.x.getTime());
            
            const smoothedPoints = [];
            
            for (let i = 0; i < sortedData.length; i++) {
                const halfWindow = Math.floor(adaptiveWindow / 2);
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(sortedData.length - 1, i + halfWindow);
                
                // Calculate weighted moving average
                let weightedSum = 0;
                let totalWeight = 0;
                
                for (let j = start; j <= end; j++) {
                    // Use Gaussian-like weighting - closer points have more influence
                    const distance = Math.abs(j - i);
                    const weight = Math.exp(-0.5 * Math.pow(distance / (halfWindow / 2), 2));
                    
                    weightedSum += sortedData[j].y * weight;
                    totalWeight += weight;
                }
                
                smoothedPoints.push({
                    x: sortedData[i].x,
                    y: weightedSum / totalWeight
                });
            }
            
            return {
                points: smoothedPoints,
                type: 'smooth'
            };
        }
        
        // Alternative: LOWESS (LOcally WEighted Scatterplot Smoothing) for better edge handling
        function calculateLOWESS(data, bandwidth = 0.3) {
            const n = data.length;
            if (n < 5) return null;
            
            // Sort data by x value
            const sortedData = [...data].sort((a, b) => a.x.getTime() - b.x.getTime());
            const xValues = sortedData.map(d => d.x.getTime());
            const yValues = sortedData.map(d => d.y);
            
            const smoothedPoints = [];
            const h = Math.floor(bandwidth * n); // neighborhood size
            
            for (let i = 0; i < n; i++) {
                const x0 = xValues[i];
                
                // Find the h nearest neighbors
                const distances = xValues.map((x, idx) => ({ 
                    distance: Math.abs(x - x0), 
                    index: idx 
                }));
                distances.sort((a, b) => a.distance - b.distance);
                
                const neighbors = distances.slice(0, h);
                const maxDist = neighbors[neighbors.length - 1].distance;
                
                if (maxDist === 0) {
                    smoothedPoints.push({
                        x: sortedData[i].x,
                        y: yValues[i]
                    });
                    continue;
                }
                
                // Calculate weighted linear regression
                let sumW = 0, sumWX = 0, sumWY = 0, sumWXX = 0, sumWXY = 0;
                
                for (const neighbor of neighbors) {
                    const idx = neighbor.index;
                    const x = xValues[idx];
                    const y = yValues[idx];
                    
                    // Tricube weight function
                    const u = neighbor.distance / maxDist;
                    const w = Math.pow(1 - Math.pow(u, 3), 3);
                    
                    sumW += w;
                    sumWX += w * x;
                    sumWY += w * y;
                    sumWXX += w * x * x;
                    sumWXY += w * x * y;
                }
                
                // Solve for linear regression coefficients
                const denominator = sumW * sumWXX - sumWX * sumWX;
                if (Math.abs(denominator) < 1e-10) {
                    smoothedPoints.push({
                        x: sortedData[i].x,
                        y: sumWY / sumW
                    });
                } else {
                    const a = (sumW * sumWXY - sumWX * sumWY) / denominator;
                    const b = (sumWXX * sumWY - sumWX * sumWXY) / denominator;
                    
                    smoothedPoints.push({
                        x: sortedData[i].x,
                        y: a * x0 + b
                    });
                }
            }
            
            return {
                points: smoothedPoints,
                type: 'lowess'
            };
        }
        
        // Simple but effective Savitzky-Golay filter for smooth trends
        function calculateSavitzkyGolay(data, windowSize = 5, polyOrder = 2) {
            const n = data.length;
            if (n < windowSize) return null;
            
            // Ensure odd window size
            const window = windowSize % 2 === 0 ? windowSize + 1 : windowSize;
            const halfWindow = Math.floor(window / 2);
            
            // Sort data by x value
            const sortedData = [...data].sort((a, b) => a.x.getTime() - b.x.getTime());
            const yValues = sortedData.map(d => d.y);
            
            const smoothedY = [];
            
            for (let i = 0; i < n; i++) {
                const start = Math.max(0, i - halfWindow);
                const end = Math.min(n - 1, i + halfWindow);
                
                // Simple moving average as approximation to Savitzky-Golay
                let sum = 0;
                let count = 0;
                
                for (let j = start; j <= end; j++) {
                    // Apply triangular weighting
                    const distance = Math.abs(j - i);
                    const weight = Math.max(0, halfWindow + 1 - distance);
                    sum += yValues[j] * weight;
                    count += weight;
                }
                
                smoothedY.push(sum / count);
            }
            
            const smoothedPoints = sortedData.map((point, i) => ({
                x: point.x,
                y: smoothedY[i]
            }));
            
            return {
                points: smoothedPoints,
                type: 'savgol'
            };
        }

        // Generate smooth trend line data points
        function generateTrendLine(data, smoothResult) {
            if (!smoothResult || !smoothResult.points || smoothResult.points.length < 2) return [];
            
            // Return the smoothed points directly - they're already properly ordered
            return smoothResult.points;
        }

        async function fetchDebugData() {
            try {
                const response = await fetch('https://tide-monitor-boron-default-rtdb.firebaseio.com/readings/.json?orderBy="$key"&limitToLast=1440');
                const data = await response.json();
                
                const readings = Object.entries(data).map(([key, value]) => ({
                    id: key,
                    timestamp: new Date(value.t).toLocaleString('en-US', { 
                        timeZone: 'America/New_York',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    }),
                    rawTimestamp: new Date(value.t),
                    waterLevel: (value.w / 304.8).toFixed(2),
                    wavesPercentile: (value.hp !== undefined && value.hp !== null) ? (value.hp / 304.8).toFixed(2) : '--',
                    wavesEnvelope: (value.he !== undefined && value.he !== null) ? (value.he / 304.8).toFixed(2) : '--',
                    waterLevelPercentile: (value.wp !== undefined && value.wp !== null) ? (value.wp / 304.8).toFixed(2) : '--',
                    waterLevelEnvelope: (value.we !== undefined && value.we !== null) ? (value.we / 304.8).toFixed(2) : '--',
                    validSamples: value.vs || '--',
                    validSamplesRaw: value.vs || 0,
                    // NOAA data from Duke Marine Lab
                    dukeWaterLevel: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm).toFixed(2) : '--',
                    dukeWaterLevelRaw: (value.wm !== undefined && value.wm !== null && value.wm !== "-999") ? parseFloat(value.wm) : null,
                    windSpeed: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944).toFixed(1) : '--', // Convert m/s to knots
                    windSpeedRaw: (value.ws !== undefined && value.ws !== null && value.ws !== "-999") ? (parseFloat(value.ws) * 1.944) : null,
                    gustSpeed: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944).toFixed(1) : '--', // Convert m/s to knots
                    gustSpeedRaw: (value.gs !== undefined && value.gs !== null && value.gs !== "-999") ? (parseFloat(value.gs) * 1.944) : null
                }));
                
                // Store readings for trend line calculations
                currentReadings = readings;
                
                // Create debug chart with all data
                createDebugChart(readings);
                
                // Hide loading and show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');
            } catch (error) {
                console.error('Error fetching debug data:', error);
                document.getElementById('loading').textContent = 'Error loading data. Check console for details.';
            }
        }

        function createDebugChart(readings) {
            // Destroy existing chart if it exists
            if (debugChartInstance) {
                debugChartInstance.destroy();
            }
            
            const ctx = document.getElementById('debugChart').getContext('2d');
            
            // Filter out any invalid timestamps
            const validReadings = readings.filter(r => r.rawTimestamp.getTime() > 0);
            
            // Set time range to exactly 24 hours ago to now
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            
            
            debugChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Water Level (Average)',
                        data: validReadings.map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevel)})),
                        borderColor: 'rgba(0, 0, 255, 1)',
                        backgroundColor: 'rgba(0, 0, 255, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 1
                    }, {
                        label: 'Water Level (Percentile)',
                        data: validReadings.filter(r => r.waterLevelPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevelPercentile)})),
                        borderColor: 'rgba(0, 255, 255, 1)',
                        backgroundColor: 'rgba(0, 255, 255, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 2
                    }, {
                        label: 'Water Level (Envelope)',
                        data: validReadings.filter(r => r.waterLevelEnvelope !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevelEnvelope)})),
                        borderColor: 'rgba(255, 0, 255, 1)',
                        backgroundColor: 'rgba(255, 0, 255, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 3
                    }, {
                        label: 'Wave Height (Percentile)',
                        data: validReadings.filter(r => r.wavesPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesPercentile)})),
                        borderColor: 'rgba(255, 0, 0, 1)',
                        backgroundColor: 'rgba(255, 0, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y1',
                        order: 5
                    }, {
                        label: 'Wave Height (Envelope)',
                        data: validReadings.filter(r => r.wavesEnvelope !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesEnvelope)})),
                        borderColor: 'rgba(255, 165, 0, 1)',
                        backgroundColor: 'rgba(255, 165, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y1',
                        order: 6
                    }, {
                        label: 'Valid Samples',
                        data: validReadings.map(r => ({x: r.rawTimestamp, y: r.validSamplesRaw})),
                        borderColor: 'rgba(128, 128, 128, 1)',
                        backgroundColor: 'rgba(128, 128, 128, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y2',
                        order: 8
                    }, {
                        label: 'Duke Marine Lab Water Level',
                        data: validReadings.filter(r => r.dukeWaterLevelRaw !== null).map(r => ({x: r.rawTimestamp, y: r.dukeWaterLevelRaw + 1.2})),
                        borderColor: 'rgba(0, 0, 139, 1)',
                        backgroundColor: 'rgba(0, 0, 139, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y',
                        order: 0,
                        borderDash: [5, 5]
                    }, {
                        label: 'Wind Speed',
                        data: validReadings.filter(r => r.windSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.windSpeedRaw})),
                        borderColor: 'rgba(0, 128, 0, 1)',
                        backgroundColor: 'rgba(0, 128, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y3',
                        order: 9
                    }, {
                        label: 'Gust Speed',
                        data: validReadings.filter(r => r.gustSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.gustSpeedRaw})),
                        borderColor: 'rgba(0, 100, 0, 1)',
                        backgroundColor: 'rgba(0, 100, 0, 0.1)',
                        borderWidth: 1,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        yAxisID: 'y3',
                        order: 10,
                        borderDash: [3, 3]
                    }]
                },
                options: {
                    animation: false,
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            min: 0,
                            max: 6,
                            title: {
                                display: true,
                                text: 'Water Level (feet)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 2,
                            title: {
                                display: true,
                                text: 'Wave Height (feet)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 512,
                            display: false,
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        y3: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 30,
                            title: {
                                display: true,
                                text: 'Wind Speed (knots)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        x: {
                            type: 'time',
                            min: twentyFourHoursAgo,
                            max: now,
                            time: {
                                displayFormats: {
                                    hour: 'h:mm a'
                                }
                            },
                            title: {
                                display: false
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: false
                        }
                    }
                }
            });
            
            // Generate custom legend
            const legendContainer = document.getElementById('chartLegend');
            if (legendContainer) {
                const legendItems = [
                    { label: 'Water Level (Average)', color: 'blue' },
                    { label: 'Duke Marine Lab Water Level', color: 'darkblue', dash: true },
                    { label: 'Water Level (Percentile)', color: 'cyan' },
                    { label: 'Water Level (Envelope)', color: 'magenta' },
                    { label: 'Wave Height (Percentile)', color: 'red' },
                    { label: 'Wave Height (Envelope)', color: 'orange' },
                    { label: 'Wind Speed', color: 'green' },
                    { label: 'Gust Speed', color: 'darkgreen', dot: true },
                    { label: 'Valid Samples', color: 'gray' }
                ];
                
                legendContainer.innerHTML = legendItems.map(item => `
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 16px; height: 3px; background-color: ${item.color}; display: inline-block; ${item.dash ? 'background-image: repeating-linear-gradient(to right, ' + item.color + ' 0px, ' + item.color + ' 2px, transparent 2px, transparent 4px);' : item.dot ? 'background-image: repeating-linear-gradient(to right, ' + item.color + ' 0px, ' + item.color + ' 1px, transparent 1px, transparent 3px);' : ''}"></span>
                        <span>${item.label}</span>
                    </span>
                `).join('');
            }
            
            // Add trend lines if enabled
            if (trendLinesVisible) {
                addTrendLines();
            }
        }

        // Add trend lines to existing chart
        function addTrendLines() {
            if (!debugChartInstance || !currentReadings.length) return;
            
            const validReadings = currentReadings.filter(r => r.rawTimestamp.getTime() > 0);
            
            // Reduce opacity of original datasets (all except Valid Samples)
            debugChartInstance.data.datasets.forEach((dataset, index) => {
                if (index !== 5) { // Skip Valid Samples (index 5)
                    dataset.borderColor = dataset.borderColor.replace(/rgba\(([^,]+),\s*([^,]+),\s*([^,]+),\s*[^)]+\)/, (match, r, g, b) => {
                        return `rgba(${r}, ${g}, ${b}, 0.3)`;
                    });
                    dataset.backgroundColor = dataset.backgroundColor.replace(/rgba\(([^,]+),\s*([^,]+),\s*([^,]+),\s*[^)]+\)/, (match, r, g, b) => {
                        return `rgba(${r}, ${g}, ${b}, 0.05)`;
                    });
                }
            });
            
            // Define datasets that need trend lines (all except Valid Samples)
            const trendLineConfigs = [
                {
                    datasetIndex: 0,
                    label: 'Water Level (Average) - Trend',
                    data: validReadings.map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevel)})),
                    borderColor: 'rgba(0, 0, 255, 0.8)',
                    yAxisID: 'y'
                },
                {
                    datasetIndex: 1,
                    label: 'Water Level (Percentile) - Trend',
                    data: validReadings.filter(r => r.waterLevelPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevelPercentile)})),
                    borderColor: 'rgba(0, 255, 255, 0.8)',
                    yAxisID: 'y'
                },
                {
                    datasetIndex: 2,
                    label: 'Water Level (Envelope) - Trend',
                    data: validReadings.filter(r => r.waterLevelEnvelope !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.waterLevelEnvelope)})),
                    borderColor: 'rgba(255, 0, 255, 0.8)',
                    yAxisID: 'y'
                },
                {
                    datasetIndex: 3,
                    label: 'Wave Height (Percentile) - Trend',
                    data: validReadings.filter(r => r.wavesPercentile !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesPercentile)})),
                    borderColor: 'rgba(255, 0, 0, 0.8)',
                    yAxisID: 'y1'
                },
                {
                    datasetIndex: 4,
                    label: 'Wave Height (Envelope) - Trend',
                    data: validReadings.filter(r => r.wavesEnvelope !== '--').map(r => ({x: r.rawTimestamp, y: parseFloat(r.wavesEnvelope)})),
                    borderColor: 'rgba(255, 165, 0, 0.8)',
                    yAxisID: 'y1'
                },
                {
                    datasetIndex: 6,
                    label: 'Duke Marine Lab Water Level - Trend',
                    data: validReadings.filter(r => r.dukeWaterLevelRaw !== null).map(r => ({x: r.rawTimestamp, y: r.dukeWaterLevelRaw + 1.2})),
                    borderColor: 'rgba(0, 0, 139, 0.8)',
                    yAxisID: 'y'
                },
                {
                    datasetIndex: 7,
                    label: 'Wind Speed - Trend',
                    data: validReadings.filter(r => r.windSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.windSpeedRaw})),
                    borderColor: 'rgba(0, 128, 0, 0.8)',
                    yAxisID: 'y3'
                },
                {
                    datasetIndex: 8,
                    label: 'Gust Speed - Trend',
                    data: validReadings.filter(r => r.gustSpeedRaw !== null).map(r => ({x: r.rawTimestamp, y: r.gustSpeedRaw})),
                    borderColor: 'rgba(0, 100, 0, 0.8)',
                    yAxisID: 'y3'
                }
            ];
            
            // Calculate and add trend lines
            trendLineConfigs.forEach(config => {
                if (config.data.length >= 5) { // Need at least 5 points for smoothing
                    // Try LOWESS first, fallback to moving average
                    let smoothResult = calculateLOWESS(config.data, 0.3);
                    if (!smoothResult) {
                        smoothResult = calculateSmoothTrend(config.data, 0.15);
                    }
                    
                    if (smoothResult) {
                        const trendData = generateTrendLine(config.data, smoothResult);
                        
                        if (trendData && trendData.length > 0) {
                            debugChartInstance.data.datasets.push({
                                label: config.label,
                                data: trendData,
                                borderColor: config.borderColor,
                                backgroundColor: 'transparent',
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 0,
                                yAxisID: config.yAxisID,
                                order: 100 + config.datasetIndex,
                                borderDash: [10, 5]
                            });
                        }
                    } else {
                        console.warn(`Failed to calculate smooth trend for ${config.label}`);
                    }
                }
            });
            
            debugChartInstance.update();
        }

        // Remove trend lines from chart
        function removeTrendLines() {
            if (!debugChartInstance) return;
            
            // Remove all trend line datasets (those with "Trend" in their label)
            debugChartInstance.data.datasets = debugChartInstance.data.datasets.filter(dataset => 
                !dataset.label.includes('Trend')
            );
            
            // Restore original opacity for original datasets (all except Valid Samples)
            debugChartInstance.data.datasets.forEach((dataset, index) => {
                if (index !== 5) { // Skip Valid Samples (index 5)
                    // Restore original colors based on dataset type
                    if (dataset.label === 'Water Level (Average)') {
                        dataset.borderColor = 'rgba(0, 0, 255, 1)';
                        dataset.backgroundColor = 'rgba(0, 0, 255, 0.1)';
                    } else if (dataset.label === 'Water Level (Percentile)') {
                        dataset.borderColor = 'rgba(0, 255, 255, 1)';
                        dataset.backgroundColor = 'rgba(0, 255, 255, 0.1)';
                    } else if (dataset.label === 'Water Level (Envelope)') {
                        dataset.borderColor = 'rgba(255, 0, 255, 1)';
                        dataset.backgroundColor = 'rgba(255, 0, 255, 0.1)';
                    } else if (dataset.label === 'Wave Height (Percentile)') {
                        dataset.borderColor = 'rgba(255, 0, 0, 1)';
                        dataset.backgroundColor = 'rgba(255, 0, 0, 0.1)';
                    } else if (dataset.label === 'Wave Height (Envelope)') {
                        dataset.borderColor = 'rgba(255, 165, 0, 1)';
                        dataset.backgroundColor = 'rgba(255, 165, 0, 0.1)';
                    } else if (dataset.label === 'Duke Marine Lab Water Level') {
                        dataset.borderColor = 'rgba(0, 0, 139, 1)';
                        dataset.backgroundColor = 'rgba(0, 0, 139, 0.1)';
                    } else if (dataset.label === 'Wind Speed') {
                        dataset.borderColor = 'rgba(0, 128, 0, 1)';
                        dataset.backgroundColor = 'rgba(0, 128, 0, 0.1)';
                    } else if (dataset.label === 'Gust Speed') {
                        dataset.borderColor = 'rgba(0, 100, 0, 1)';
                        dataset.backgroundColor = 'rgba(0, 100, 0, 0.1)';
                    }
                }
            });
            
            debugChartInstance.update();
        }

        // Toggle trend lines visibility
        function toggleTrendLines() {
            trendLinesVisible = !trendLinesVisible;
            
            const button = document.getElementById('toggleTrendlines');
            if (trendLinesVisible) {
                button.textContent = 'Hide Trend Lines';
                button.classList.add('active');
                addTrendLines();
            } else {
                button.textContent = 'Show Trend Lines';
                button.classList.remove('active');
                removeTrendLines();
            }
        }

        // Initialize toggle button event listener
        window.addEventListener('load', function() {
            document.getElementById('toggleTrendlines').addEventListener('click', toggleTrendLines);
        });
    </script>
</body>
</html>